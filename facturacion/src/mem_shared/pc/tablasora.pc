#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sqlca.h>
#include <sqlcpr.h>
#include <pthread.h>

#include "GenORA.h"
#include "tipos.h"
#include "tablas.h"

EXEC SQL BEGIN DECLARE SECTION;
    int   ihpUno = 1 ;
EXEC SQL END DECLARE SECTION;

/******************************************************************************
Funcion         :       ifnInitORATh
*******************************************************************************/
int ifnInitORATh (char * szUser,char * szPass,int *iCodCiclo,int iFactura, char *szFecSysDate)
{
    struct sqlca sqlca;
    EXEC SQL BEGIN DECLARE SECTION;
        int icod_ciclo=0;
        int icod_factura=0;
        static char* szhSysDate           ; EXEC SQL VAR szhSysDate       IS STRING(15);
        EXEC SQL END DECLARE SECTION;

    char szConnect[255];
    memset(szConnect,0x00,sizeof(szConnect));

    sprintf(szConnect,"%s/%s", szUser, szPass);

    szhSysDate=szFecSysDate;

        icod_factura=iFactura;
    EXEC SQL CONNECT :szConnect;
        fprintf(stdout,"\n sqlca.sqlcode 1 ==>[%d] \n",sqlca.sqlcode);
    if(sqlca.sqlcode)
    {
        icod_ciclo=-1;
                *iCodCiclo=icod_ciclo;
        return sqlca.sqlcode;
    }

    fprintf(stdout,"\n[CARGA INICIAL] - COD_CICLFACT ==>[%d] ).\n",icod_factura);

    EXEC SQL SELECT COD_CICLO INTO :icod_ciclo FROM FA_CICLFACT WHERE COD_CICLFACT=:icod_factura;

    fprintf(stdout,"\n[CARGA INICIAL] - COD_CICLO ==>[%d] ).\n",icod_ciclo);
    fprintf(stdout,"\n sqlca.sqlcode 2 ==>[%d] \n",sqlca.sqlcode);
  if(sqlca.sqlcode)
    {
        icod_ciclo=-1;
                *iCodCiclo=icod_ciclo;
        return sqlca.sqlcode;
    }
    *iCodCiclo=icod_ciclo;

    EXEC SQL SELECT TO_CHAR(SYSDATE,'YYYYMMDDHH24MISS') INTO :szhSysDate FROM FA_DATOSGENER;
    if(sqlca.sqlcode)
    {
        icod_ciclo=-1;
                *iCodCiclo=icod_ciclo;
        return sqlca.sqlcode;
    }

    EXEC SQL ENABLE THREADS;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnCommitReleaseTh
*******************************************************************************/

int ifnCommitReleaseTh(sql_context ctx)
{
    struct sqlca sqlca;

    EXEC SQL CONTEXT USE :ctx;

    EXEC SQL COMMIT RELEASE;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnConnectORATh
*******************************************************************************/

int ifnConnectORATh(char * szUser,char * szPass,sql_context *ctx)
{
    sql_context p;
    struct sqlca sqlca;
    char szConnect[255];
    memset(szConnect,0x00,sizeof(szConnect));
    sprintf(szConnect,"%s/%s", szUser, szPass);

/* bloqueo para evitar colicion de conexiones */
pthread_mutex_lock (&mutexIO);

    EXEC SQL CONTEXT ALLOCATE :p;

    if(sqlca.sqlcode)
        return sqlca.sqlcode;

    EXEC SQL CONTEXT USE :p;

    EXEC SQL CONNECT :szConnect;

    if (sqlca.sqlcode)
            return sqlca.sqlcode;

        EXEC SQL ALTER SESSION SET NLS_DATE_FORMAT = 'YYYYMMDDHH24MISS';

    vfnActivateRoleTh(szUser,&p);

    *ctx = p;

/* bloqueo para evitar colicion de conexiones */
    pthread_mutex_unlock (&mutexIO);

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       vfnActivateRoleTh
*******************************************************************************/
void vfnActivateRoleTh (char *szUser,sql_context ctx)
{
    struct sqlca sqlca;
    EXEC SQL CONTEXT USE :ctx;

    EXEC SQL BEGIN DECLARE SECTION;

        char szhCad[20]         ; EXEC SQL VAR szhCad           IS STRING(20) ;
        char szhStm[512]        ; EXEC SQL VAR szhStm           IS STRING(255);
        char *szhUser           ; EXEC SQL VAR szhUser          IS STRING(31) ;
        char szhRA[512]         ; EXEC SQL VAR szhRA            IS STRING(512);
        char szhGrantedRole[31] ; EXEC SQL VAR szhGrantedRole   IS STRING(31);

    EXEC SQL END DECLARE SECTION;

    char szPass[10] = "";
    char szRolesActivos[502];

    szhUser = szUser;

    EXEC SQL DECLARE C_RA CURSOR FOR
        SELECT ROLE
          FROM SESSION_ROLES;

    EXEC SQL OPEN C_RA;

    if (sqlca.sqlcode)
    {
        return;
    }

    strcpy(szRolesActivos,"");

    while (1)
    {
        EXEC SQL FETCH C_RA
                 INTO :szhRA;
        if (sqlca.sqlcode == NOT_FOUND)
            break;

        if (sqlca.sqlcode <0)
        {
            fprintf(stderr,"* Error FETCH C_RA %s\n",szfnORAerror());
            strcpy(szRolesActivos,"");
            return;
        }

        sprintf(szRolesActivos,"%s %s,",szRolesActivos,szhRA);

    }

    EXEC SQL CLOSE C_RA;

    if (sqlca.sqlcode)
    {
        fprintf(stderr,"vfnActivateRole() Close Code:%s\n", szfnORAerror());
        return;
    }

    if ((char*) strstr(szRolesActivos,"TCP_IUD") != (char*) NULL)
    {
        return;
    }

    strcpy (szhCad,"TCP_IUD");
    EXEC SQL
    SELECT GRANTED_ROLE
      INTO :szhGrantedRole
      FROM USER_ROLE_PRIVS
      WHERE GRANTED_ROLE = :szhCad
        AND USERNAME     = UPPER(:szhUser);

    if (sqlca.sqlcode == NOT_FOUND)
    {
        return;
    }

    if (sqlca.sqlcode)
    {
        fprintf(stderr,"* Error G_RO %s\n",szfnORAerror());
        return;
    }

    szPass[0] = szhCad[0];
    szPass[1] = szhCad[4];
    szPass[2] = szhCad[2];
    szPass[3] = szhCad[5];
    szPass[4] = szhCad[1];
    szPass[5] = szhCad[3];
    szPass[6] = '6';
    szPass[7] = 'C';
    szPass[8] = '\0';

    sprintf(szhStm,"SET ROLE %s TCP_IUD IDENTIFIED BY %s\n",szRolesActivos,szPass);

    EXEC SQL EXECUTE IMMEDIATE :szhStm;

    return;
}

/******************************************************************************
Funcion         :       ifnOraDeclararFacClientes
*******************************************************************************/

int ifnOraDeclararFacClientes(sql_context ctx, int iCodCiclo, long ci, long cf)
{
        struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL BEGIN DECLARE SECTION;
        static int  ihCodCiclo  ;
        static long  lhClieIni  ;
        static long  lhClieFin  ;
        int          ihCero = 0 ;
    EXEC SQL END DECLARE SECTION  ;

    ihCodCiclo = iCodCiclo  ;
    lhClieIni=ci;
    lhClieFin=cf;
    ihpUno = 1;
    if(lhClieFin!=0)
    {
        EXEC SQL DECLARE CFacClientesR CURSOR FOR
        SELECT /*+ index (GE_CLIENTES PK_GE_CLIENTES) */
                    A.COD_CLIENTE           ,
                    A.NOM_CLIENTE           ,
                    A.NOM_APECLIEN1         ,
                    A.NOM_APECLIEN2         ,
                    A.TEF_CLIENTE1          ,
                    A.TEF_CLIENTE2          ,
                    A.COD_PAIS              ,
                    A.IND_DEBITO            ,
                    A.IMP_STOPDEBIT         ,
                    A.COD_BANCO             ,
                    A.COD_SUCURSAL          ,
                    A.IND_TIPCUENTA         ,
                    A.COD_TIPTARJETA        ,
                    A.NUM_CTACORR           ,
                    A.NUM_TARJETA           ,
                    TO_CHAR (A.FEC_VENCITARJ,'YYYYMMDDHH24MISS'),
                    A.COD_BANCOTARJ         ,
                    A.COD_TIPIDTRIB         ,
                    A.NUM_IDENT             ,
                    A.COD_ACTIVIDAD         ,
                    A.COD_OFICINA           ,
                    A.IND_FACTUR            ,
                    A.NUM_FAX               ,
                    TO_CHAR (A.FEC_ALTA,'YYYYMMDDHH24MISS'),
                    A.COD_CUENTA            ,
                    A.COD_IDIOMA            ,
                    A.COD_OPERADORA
            FROM GE_CLIENTES A
            WHERE EXISTS  (select 1 from FA_CICLOCLI AL1
                           WHERE  A.COD_CLIENTE = AL1.COD_CLIENTE
			     AND  AL1.COD_CICLO   = :ihCodCiclo
                             AND AL1.NUM_PROCESO  = :ihCero
                             AND AL1.IND_MASCARA  = :ihpUno
                             AND AL1.COD_CLIENTE >  :lhClieIni
                             AND AL1.COD_CLIENTE <= :lhClieFin);             
/*            
            , FA_CICLOCLI AL1
            WHERE   A.COD_CLIENTE = AL1.COD_CLIENTE
            AND     AL1.COD_CICLO    = :ihCodCiclo
            AND AL1.NUM_PROCESO  = :ihCero
            AND AL1.IND_MASCARA  = :ihpUno
            AND AL1.COD_CLIENTE >  :lhClieIni
            AND AL1.COD_CLIENTE <= :lhClieFin;
*/
        EXEC SQL OPEN CFacClientesR;
    }
    else
    {
        EXEC SQL DECLARE CFacClientes CURSOR FOR
        /*SELECT + index (GE_CLIENTES PK_GE_CLIENTES) 
               A.COD_CLIENTE           ,
               A.NOM_CLIENTE           ,
               A.NOM_APECLIEN1         ,
               A.NOM_APECLIEN2         ,
               A.TEF_CLIENTE1          ,
               A.TEF_CLIENTE2          ,
               A.COD_PAIS              ,
               A.IND_DEBITO            ,
               A.IMP_STOPDEBIT         ,
               A.COD_BANCO             ,
               A.COD_SUCURSAL          ,
               A.IND_TIPCUENTA         ,
               A.COD_TIPTARJETA        ,
               A.NUM_CTACORR           ,
               A.NUM_TARJETA           ,
               TO_CHAR (A.FEC_VENCITARJ,'YYYYMMDDHH24MISS'),
               A.COD_BANCOTARJ         ,
               A.COD_TIPIDTRIB         ,
               A.NUM_IDENT             ,
               A.COD_ACTIVIDAD         ,
               A.COD_OFICINA           ,
               A.IND_FACTUR            ,
               A.NUM_FAX               ,
               TO_CHAR (A.FEC_ALTA,'YYYYMMDDHH24MISS'),
               A.COD_CUENTA            ,
               A.COD_IDIOMA            ,
               A.COD_OPERADORA
          FROM GE_CLIENTES A
        WHERE EXISTS (SELECT 1 FROM FA_CICLOCLI AL1
                       WHERE A.COD_CLIENTE = AL1.COD_CLIENTE
                         AND AL1.COD_CICLO    = :ihCodCiclo
                         AND AL1.NUM_PROCESO  = :ihCero
                         AND AL1.IND_MASCARA  = :ihpUno
                         AND AL1.COD_CLIENTE >  :lhClieIni);*/
                         
        SELECT 
               DISTINCT A.COD_CLIENTE          ,
               A.NOM_CLIENTE           ,
               A.NOM_APECLIEN1         ,
               A.NOM_APECLIEN2         ,
               A.TEF_CLIENTE1          ,
               A.TEF_CLIENTE2          ,
               A.COD_PAIS              ,
               A.IND_DEBITO            ,
               A.IMP_STOPDEBIT         ,
               A.COD_BANCO             ,
               A.COD_SUCURSAL          ,
               A.IND_TIPCUENTA         ,
               A.COD_TIPTARJETA        ,
               A.NUM_CTACORR           ,
               A.NUM_TARJETA           ,
               TO_CHAR (A.FEC_VENCITARJ,'YYYYMMDDHH24MISS'),
               A.COD_BANCOTARJ         ,
               A.COD_TIPIDTRIB         ,
               A.NUM_IDENT             ,
               A.COD_ACTIVIDAD         ,
               A.COD_OFICINA           ,
               A.IND_FACTUR            ,
               A.NUM_FAX               ,
               TO_CHAR (A.FEC_ALTA,'YYYYMMDDHH24MISS'),
               A.COD_CUENTA            ,
               A.COD_IDIOMA            ,
               A.COD_OPERADORA
          FROM GE_CLIENTES A, FA_CICLOCLI AL1
                       WHERE A.COD_CLIENTE = AL1.COD_CLIENTE
                         AND AL1.COD_CICLO    = :ihCodCiclo
                         AND AL1.NUM_PROCESO  = :ihCero
                         AND AL1.IND_MASCARA  = :ihpUno
                         AND AL1.COD_CLIENTE > :lhClieIni;                 

        EXEC SQL OPEN CFacClientes;
    }

        return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararFacCiclo
*******************************************************************************/

int ifnOraDeclararFacCiclo(sql_context ctx, int iCodCiclo, long ci, long cf)
{
    struct sqlca sqlca;
    EXEC SQL CONTEXT USE :ctx;

    EXEC SQL BEGIN DECLARE SECTION;
        static int  ihCodCiclo  ;
        static long  lhClieIni  ;
        static long  lhClieFin  ;
        int    ihCero = 0;
    EXEC SQL END DECLARE SECTION  ;

    ihCodCiclo = iCodCiclo  ;
    lhClieIni=ci;
    lhClieFin=cf;
    ihpUno = 1;
    if(lhClieFin!=0)
    {
        EXEC SQL DECLARE CFacCicloR CURSOR FOR
            SELECT ROWID        ,
                   COD_CLIENTE  ,
                   COD_PRODUCTO ,
                   NUM_ABONADO  ,
                   COD_CALCLIEN ,
                   IND_CAMBIO   ,
                   NOM_USUARIO  ,
                   NOM_APELLIDO1,
                   NOM_APELLIDO2,
                   COD_CREDMOR  ,
                   IND_DEBITO   ,
                   COD_CICLONUE ,
                   TO_CHAR (FEC_ALTA, 'YYYYMMDDHH24MISS'),
                   nvl(TO_CHAR (FEC_ULTFACT, 'YYYYMMDDHH24MISS'), ' ')
              FROM FA_CICLOCLI
             WHERE COD_CICLO    = :ihCodCiclo
               AND NUM_PROCESO  = :ihCero
               AND IND_MASCARA  = :ihpUno
               AND COD_CLIENTE >  :lhClieIni
               AND COD_CLIENTE <= :lhClieFin;
        EXEC SQL OPEN CFacCicloR;
    }
    else
    {
            EXEC SQL DECLARE CFacCiclo CURSOR FOR
            SELECT ROWID        ,
                   COD_CLIENTE  ,
                   COD_PRODUCTO ,
                   NUM_ABONADO  ,
                   COD_CALCLIEN ,
                   IND_CAMBIO   ,
                   NOM_USUARIO  ,
                   NOM_APELLIDO1,
                   NOM_APELLIDO2,
                   COD_CREDMOR  ,
                   IND_DEBITO   ,
                   COD_CICLONUE ,
                   TO_CHAR (FEC_ALTA, 'YYYYMMDDHH24MISS'),
                   nvl(TO_CHAR (FEC_ULTFACT, 'YYYYMMDDHH24MISS'), ' ')
              FROM FA_CICLOCLI
             WHERE COD_CICLO    = :ihCodCiclo
               AND NUM_PROCESO  = :ihCero
               AND IND_MASCARA  = :ihpUno
               AND COD_CLIENTE >  :lhClieIni;
        EXEC SQL OPEN CFacCiclo;
    }

        return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeCargos
*******************************************************************************/

int ifnOraDeclararGeCargos (sql_context ctx, long ciclo, long ci, long cf)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL BEGIN DECLARE SECTION;
        static int  lCodCiclo  ;
        static long  lhClieIni  ;
        static long  lhClieFin  ;
        static int  ihCero  ;
        static int  ihDos  ;
    EXEC SQL END DECLARE SECTION  ;

    lCodCiclo=ciclo;
    lhClieIni=ci;
    lhClieFin=cf;

    ihCero = 0 ;
    ihpUno  = 1 ;
    ihDos  = 2 ;
    if(lhClieFin!=0)
    {
        EXEC SQL DECLARE CGeCargosR CURSOR FOR
        SELECT /*+ index (A,  AK_GE_CARGOS_CODCLIENTE) */
            A.ROWID                                ,
            A.NUM_CARGO                            ,
            A.COD_CLIENTE                          ,
            A.COD_PRODUCTO                         ,
            A.COD_CONCEPTO                         ,
            TO_CHAR (A.FEC_ALTA,'YYYYMMDDHH24MISS'),
            A.IMP_CARGO                            ,
            A.COD_MONEDA                           ,
            A.COD_PLANCOM                          ,
            A.NUM_UNIDADES                         ,
            A.NUM_ABONADO                          ,
            A.NUM_TERMINAL                         ,
            A.COD_CICLFACT                         ,
            A.NUM_SERIE                            ,
            A.NUM_SERIEMEC                         ,
            A.CAP_CODE                             ,
            A.MES_GARANTIA                         ,
            A.NUM_PREGUIA                          ,
            A.NUM_GUIA                             ,
            A.NUM_TRANSACCION                      ,
            A.NUM_VENTA                            ,
            A.NUM_FACTURA                          ,
            A.COD_CONCEPTO_DTO                     ,
            A.VAL_DTO                              ,
            A.TIP_DTO                              ,
            A.IND_CUOTA                            ,
            A.NUM_PAQUETE                          ,
            A.IND_FACTUR                           ,
            A.IND_SUPERTEL
        FROM   GE_CARGOS A, FA_CICLFACT B 
        WHERE  A.NUM_FACTURA     = :ihCero
          AND  A.NUM_TRANSACCION = :ihCero
          AND  A.IMP_CARGO      != :ihCero
          AND  A.COD_CICLFACT = B.COD_CICLFACT
          AND B.IND_FACTURACION IN (:ihpUno,:ihDos)
		  and exists (select 1
		  	  		   from fa_ciclocli CLI
					   where num_proceso=:ihCero 
					   and ind_mascara=:ihpUno 
					   and cod_ciclo=:lCodCiclo 
					   AND COD_CLIENTE >= :lhClieIni  
					   AND COD_CLIENTE <= :lhClieFin
					   and A.COD_CLIENTE = CLI.COD_CLIENTE);
					   
        EXEC SQL OPEN CGeCargosR;
    }
    else
    {
        EXEC SQL DECLARE CGeCargos CURSOR FOR
        SELECT /*+ index (A,  AK_GE_CARGOS_CODCLIENTE) */
            A.ROWID                                ,
            A.NUM_CARGO                            ,
            A.COD_CLIENTE                          ,
            A.COD_PRODUCTO                         ,
            A.COD_CONCEPTO                         ,
            TO_CHAR (A.FEC_ALTA,'YYYYMMDDHH24MISS'),
            A.IMP_CARGO                            ,
            A.COD_MONEDA                           ,
            A.COD_PLANCOM                          ,
            A.NUM_UNIDADES                         ,
            A.NUM_ABONADO                          ,
            A.NUM_TERMINAL                         ,
            A.COD_CICLFACT                         ,
            A.NUM_SERIE                            ,
            A.NUM_SERIEMEC                         ,
            A.CAP_CODE                             ,
            A.MES_GARANTIA                         ,
            A.NUM_PREGUIA                          ,
            A.NUM_GUIA                             ,
            A.NUM_TRANSACCION                      ,
            A.NUM_VENTA                            ,
            A.NUM_FACTURA                          ,
            A.COD_CONCEPTO_DTO                     ,
            A.VAL_DTO                              ,
            A.TIP_DTO                              ,
            A.IND_CUOTA                            ,
            A.NUM_PAQUETE                          ,
            A.IND_FACTUR                           ,
            A.IND_SUPERTEL
        FROM   GE_CARGOS A, FA_CICLFACT B 
        WHERE  A.NUM_FACTURA     = :ihCero
          AND  A.NUM_TRANSACCION = :ihCero
          AND  A.IMP_CARGO      != :ihCero
          AND  A.COD_CICLFACT = B.COD_CICLFACT
          AND B.IND_FACTURACION IN (:ihpUno,:ihDos)
		  and exists (select 1
		  	  		   from fa_ciclocli CLI
					   where num_proceso=:ihCero 
					   and ind_mascara=:ihpUno 
					   and cod_ciclo=:lCodCiclo 
					   AND COD_CLIENTE >= :lhClieIni  
					   and A.COD_CLIENTE = CLI.COD_CLIENTE);

        EXEC SQL OPEN CGeCargos;
    }

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeCabCuotas
*******************************************************************************/

int ifnOraDeclararGeCabCuotas (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeCabCuotas CURSOR FOR
    SELECT
        ROWID
        ,SEQ_CUOTAS
        ,COD_CLIENTE
        ,COD_CONCEPTO
        ,COD_MONEDA
        ,COD_PRODUCTO
        ,NUM_CUOTAS
        ,IMP_TOTAL
        ,IND_PAGADA
        ,NUM_ABONADO
        ,COD_CUOTA
        ,NUM_PAGARE
    FROM
    FA_CABCUOTAS;

    EXEC SQL OPEN CGeCabCuotas;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeTaConcepFact
*******************************************************************************/

int ifnOraDeclararGeTaConcepFact (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeTaConcepFact CURSOR FOR
    SELECT
        COD_PRODUCTO
        ,COD_FACTURACION
        ,IND_TABLA
        ,IND_ENTSAL
        ,IND_DESTINO
        ,COD_TARIFICACION
        ,COD_SERVICIO
    FROM
    TA_CONCEPFACT;

    EXEC SQL OPEN CGeTaConcepFact;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeConceptos
*******************************************************************************/

int ifnOraDeclararGeConceptos (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeConceptos CURSOR FOR
    SELECT /*+ FULL(FA_CONCEPTOS) */
                 A.COD_CONCEPTO,
                 A.COD_PRODUCTO,
                 A.DES_CONCEPTO,
                 A.COD_TIPCONCE,
                 A.COD_MODULO  ,
                 A.COD_MONEDA  ,
                 A.IND_ACTIVO  ,
                 A.COD_CONCORIG,
                 A.COD_TIPDESCU,
                 A.IND_TECNOLOGIA,
                 A.DEF_TECNOLOGIA,
                 B.COD_CONCCOBR
          FROM   FA_CONCEPTOS A, FA_FACTCOBR B
          WHERE  A.COD_CONCEPTO = B.COD_CONCFACT
            /*AND  A.COD_PRODUCTO = 1*/
          ORDER BY COD_CONCEPTO;

    EXEC SQL OPEN CGeConceptos;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeConceptos_Mi
*******************************************************************************/

int ifnOraDeclararGeConceptos_Mi (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeConceptos_Mi CURSOR FOR

    SELECT /*+ FULL(GE_MULTIIDIOMA) */
           to_number(COD_CONCEPTO),
           COD_IDIOMA  ,
           DES_CONCEPTO
      FROM GE_MULTIIDIOMA
     WHERE NOM_TABLA = 'FA_CONCEPTOS'
       AND NOM_CAMPO = 'COD_CONCEPTO'
     ORDER BY to_number(COD_CONCEPTO);

    EXEC SQL OPEN CGeConceptos_Mi;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeRangoTabla
*******************************************************************************/

int ifnOraDeclararGeRangoTabla (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeRangoTabla CURSOR FOR
    SELECT
         COD_CICLFACT
        ,RANGO_INI
        ,RANGO_FIN
        ,COD_PRODUCTO
        ,NOM_TABLA
    FROM
    FA_RANGO_TABLA;

    EXEC SQL OPEN CGeRangoTabla;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeLimCreditos
*******************************************************************************/

int ifnOraDeclararGeLimCreditos (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeLimCreditos CURSOR FOR
    SELECT
    ROWID
        ,COD_CREDMOR
        ,COD_PRODUCTO
        ,COD_CALCLIEN
        ,DES_CREDMOR
        ,IMP_MOROSIDAD
    FROM
    CO_LIMCREDITOS;

    EXEC SQL OPEN CGeLimCreditos;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeActividades
*******************************************************************************/

int ifnOraDeclararGeActividades (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeActividades CURSOR FOR
    SELECT
        ROWID
        ,COD_Actividad
        ,DES_Actividad
    FROM
    GE_ACTIVIDADES;

    EXEC SQL OPEN CGeActividades;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeProvincias
*******************************************************************************/

int ifnOraDeclararGeProvincias (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeProvincias CURSOR FOR
    SELECT
        ROWID
        ,COD_REGION
        ,COD_PROVINCIA
        ,DES_PROVINCIA
    FROM
    GE_PROVINCIAS;

    EXEC SQL OPEN CGeProvincias;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeRegiones
*******************************************************************************/

int ifnOraDeclararGeRegiones (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeRegiones CURSOR FOR
    SELECT
        ROWID
        ,COD_REGION
        ,DES_REGION
    FROM
    GE_REGIONES;

    EXEC SQL OPEN CGeRegiones;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeCatImpositiva
*******************************************************************************/

int ifnOraDeclararGeCatImpositiva (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeCatImpositiva CURSOR FOR
    SELECT
        ROWID
        ,COD_CATIMPOS
        ,DES_CATIMPOS
    FROM
    GE_CATIMPOSITIVA;

    EXEC SQL OPEN CGeCatImpositiva;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeZonaCiudad
*******************************************************************************/

int ifnOraDeclararGeZonaCiudad (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeZonaCiudad CURSOR FOR
    SELECT COD_REGION
         , COD_PROVINCIA
         , COD_CIUDAD
         , TO_CHAR (FEC_DESDE,'YYYYMMDDHH24MISS')
         , TO_CHAR (FEC_HASTA,'YYYYMMDDHH24MISS')
         , COD_ZONAIMPO
    FROM
    GE_ZONACIUDAD;

    EXEC SQL OPEN CGeZonaCiudad;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeZonaImpositiva
*******************************************************************************/

int ifnOraDeclararGeZonaImpositiva (sql_context ctx)
{

    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeZonaImp CURSOR FOR
    SELECT  ROWID,COD_ZONAIMPO  ,DES_ZONAIMPO FROM  GE_ZONAIMPOSITIVA;

    EXEC SQL OPEN CGeZonaImp;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeImpuestos
*******************************************************************************/

int ifnOraDeclararGeImpuestos (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeImpuestos CURSOR FOR
    SELECT
        ROWID
        ,COD_CATIMPOS
        ,COD_ZONAIMPO
        ,COD_TIPIMPUES
        ,COD_GRPSERVI
        ,TO_CHAR (FEC_DESDE,'YYYYMMDD')||'000000'
        ,COD_CONCGENE
        ,TO_CHAR (FEC_HASTA,'YYYYMMDD')||'235959'
        ,PRC_IMPUESTO
    FROM GE_IMPUESTOS
    WHERE PRC_IMPUESTO > 0.0;

    EXEC SQL OPEN CGeImpuestos;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeTipImpues
*******************************************************************************/

int ifnOraDeclararGeTipImpues (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeTipImpues CURSOR FOR
    SELECT
        ROWID
        ,COD_TIPIMPUE
        ,DES_TIPIMPUE
        ,IMP_UMBRAL
    FROM
    GE_TIPIMPUES;

    EXEC SQL OPEN CGeTipImpues;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeGrpSerConc
*******************************************************************************/

int ifnOraDeclararGeGrpSerConc (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeGrpSerConc CURSOR FOR
    SELECT COD_CONCEPTO
        ,TO_CHAR (FEC_DESDE,'YYYYMMDDHH24MISS')
        ,COD_GRPSERVI
        ,TO_CHAR (FEC_HASTA,'YYYYMMDDHH24MISS')
    FROM
    FA_GRPSERCONC;

    EXEC SQL OPEN CGeGrpSerConc;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeConversion
*******************************************************************************/

int ifnOraDeclararGeConversion (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeConversion CURSOR FOR
    SELECT COD_MONEDA
        ,TO_CHAR (FEC_DESDE,'YYYYMMDDHH24MISS')
        ,TO_CHAR (FEC_HASTA,'YYYYMMDDHH24MISS')
        ,CAMBIO
     FROM GE_CONVERSION
     WHERE (FEC_HASTA IS NULL OR ADD_MONTHS(FEC_HASTA, 24) >= SYSDATE);

    EXEC SQL OPEN CGeConversion;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeDocumSucursal
*******************************************************************************/

int ifnOraDeclararGeDocumSucursal (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    ihpUno = 1;

    EXEC SQL DECLARE CGeDocumSucursal CURSOR FOR
    SELECT SUCUR.ROWID
          ,SUCUR.COD_OFICINA
          ,SUCUR.COD_TIPDOCUM
          ,SUCUR.COD_CENTREMI
      FROM AL_DOCUM_SUCURSAL SUCUR,
           FA_TIPDOCUMEN DOCUM
     WHERE DOCUM.IND_CICLO = :ihpUno
       AND SUCUR.COD_TIPDOCUM = DOCUM.COD_TIPDOCUMMOV;

    EXEC SQL OPEN CGeDocumSucursal;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeLetras
*******************************************************************************/

int ifnOraDeclararGeLetras (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeLetras CURSOR FOR
    SELECT
        ROWID
        ,COD_TIPDOCUM
        ,COD_CATIMPOS
        ,LETRA
    FROM
    GE_LETRAS;

    EXEC SQL OPEN CGeLetras;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeGrupoCob
*******************************************************************************/

int ifnOraDeclararGeGrupoCob (sql_context ctx, int iCodCiclo)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

  EXEC SQL BEGIN DECLARE SECTION;
  static int    ihCodCiclo   ;
  EXEC SQL END DECLARE SECTION  ;

    ihCodCiclo = iCodCiclo;

    EXEC SQL DECLARE CGeGrupoCob CURSOR FOR
    SELECT COD_GRUPO
         , COD_PRODUCTO
         , COD_CONCEPTO
         , TIP_COBRO
         , FEC_DESDE
         , FEC_HASTA
         , TIP_COBROANT
      FROM FA_GRUPOCOB
     WHERE COD_CICLO = :ihCodCiclo;

    EXEC SQL OPEN CGeGrupoCob;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeTarifas
*******************************************************************************/

int ifnOraDeclararGeTarifas (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeTarifas CURSOR FOR
    SELECT
         COD_TIPSERV
        ,COD_SERVICIO
        ,COD_PLANSERV
        ,TO_CHAR(FEC_DESDE,'YYYYMMDDHH24MISS')
        ,IMP_TARIFA
        ,COD_MONEDA
        ,IND_PERIODICO
        ,TO_CHAR(FEC_HASTA,'YYYYMMDDHH24MISS')
    FROM GA_TARIFAS
    WHERE COD_PRODUCTO= 1
          AND COD_ACTABO  = 'FA';

    EXEC SQL OPEN CGeTarifas;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeActuaServ
*******************************************************************************/

int ifnOraDeclararGeActuaServ (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeActuaServ CURSOR FOR
    SELECT COD_TIPSERV
        ,COD_SERVICIO
        ,COD_CONCEPTO
    FROM GA_ACTUASERV
    WHERE COD_PRODUCTO = 1
    AND COD_ACTABO = 'FA';

    EXEC SQL OPEN CGeActuaServ;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeCuotas
*******************************************************************************/

int ifnOraDeclararGeCuotas (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeCuotas CURSOR FOR
    SELECT
        ROWID
        ,SEQ_CUOTAS
        ,ORD_CUOTA
        ,TO_CHAR (FEC_EMISION,'YYYYMMDDHH24MISS')
        ,IMP_CUOTA
        ,IND_FACTURADO
        ,IND_PAGADO
    FROM
    FA_CUOTAS;

    EXEC SQL OPEN CGeCuotas;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeFactCarriers
*******************************************************************************/

int ifnOraDeclararGeFactCarriers (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeFactCarriers CURSOR FOR
    SELECT
        COD_CONCFACT
        ,COD_CONCCARRIER
    FROM
    FA_FACTCARRIERS;

    EXEC SQL OPEN CGeFactCarriers;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeCuadCtoPlan
*******************************************************************************/

int ifnOraDeclararGeCuadCtoPlan (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeCuadCtoPlan CURSOR FOR
    SELECT
        ROWID
        ,COD_CTOPLAN
        ,IMP_UMBDESDE
        ,IMP_UMBHASTA
        ,IMP_DESCUENTO
        ,COD_TIPODTO
    FROM
    VE_CUADCTOPLAN;

    EXEC SQL OPEN CGeCuadCtoPlan;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeCtoPlan
*******************************************************************************/

int ifnOraDeclararGeCtoPlan (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeCtoPlan CURSOR FOR
    SELECT
        ROWID
        ,COD_CTOPLAN
        ,COD_PRODUCTO
        ,COD_TIPCTOPLAN
        ,COD_MONEDA
        ,COD_CTOFAC
        ,IMP_DESCUENTO
        ,COD_TIPODTO
        ,IND_CUADRANTE
        ,COD_TIPOCUAD
        ,NOM_USUARIO
        ,IMP_UMBDESDE
        ,IMP_UMBHASTA
        ,NUM_DIAS
    FROM
    VE_CTOPLAN;

    EXEC SQL OPEN CGeCtoPlan;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGePlanCtoPlan
*******************************************************************************/

int ifnOraDeclararGePlanCtoPlan (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGePlanCtoPlan CURSOR FOR
    SELECT
        ROWID
        ,COD_PLANCOM
        ,COD_PRODUCTO
        ,COD_CTOPLAN
        ,TO_CHAR (FEC_EFECTIVIDAD,'YYYYMMDDHH24MISS')
        ,TO_CHAR (FEC_FINEFECTIVIDAD,'YYYYMMDDHH24MISS')
        ,NOM_USUARIO
    FROM
    VE_PLAN_CTOPLAN;

    EXEC SQL OPEN CGePlanCtoPlan;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeArriendo
*******************************************************************************/

int ifnOraDeclararGeArriendo (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeArriendo CURSOR FOR
    SELECT
        ROWID
        ,COD_CLIENTE
        ,NUM_ABONADO
        ,TO_CHAR (FEC_DESDE,'YYYYMMDDHH24MISS')
        ,TO_CHAR (FEC_HASTA,'YYYYMMDDHH24MISS')
        ,COD_PRODUCTO
        ,COD_CONCEPTO
        ,COD_ARTICULO
        ,PRECIO_MES
        ,COD_MONEDA
    FROM
    FA_ARRIENDO;

    EXEC SQL OPEN CGeArriendo;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeCargosBasico
*******************************************************************************/

int ifnOraDeclararGeCargosBasico (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeCargosBasico CURSOR FOR
    SELECT COD_PRODUCTO
        ,COD_CARGOBASICO
        ,to_char(FEC_DESDE, 'yyyymmddhh24miss')
        ,NVL(to_char(FEC_HASTA, 'yyyymmddhh24miss'), '30000101000000')
        ,IMP_CARGOBASICO
        ,COD_MONEDA
    FROM
    TA_CARGOSBASICO;

    EXEC SQL OPEN CGeCargosBasico;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeOptimo
*******************************************************************************/

int ifnOraDeclararGeOptimo (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeOptimo CURSOR FOR
    SELECT
        COD_PLANTARIF
        ,MIN_DESDE
        ,MIN_HASTA
        ,PRC_ABONO
        ,PRC_NORMAL
        ,PRC_BAJO
    FROM
    FA_OPTIMO;

    EXEC SQL OPEN CGeOptimo;

    return sqlca.sqlcode;
}
/******************************************************************************
Funcion         :       ifnOraDeclararFacClientes
*******************************************************************************/

int ifnOraDeclararGeFeriados (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeFeriados CURSOR FOR
    SELECT
        TO_CHAR(FEC_DIAFEST,'YYYYMMDDHH24MISS')
    FROM
    TA_DIASFEST;

    EXEC SQL OPEN CGeFeriados;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGePlanTarif
*******************************************************************************/

int ifnOraDeclararGePlanTarif (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGePlanTarif CURSOR FOR
    SELECT COD_PRODUCTO
        ,COD_PLANTARIF
        ,TIP_TERMINAL
        ,COD_LIMCONSUMO
        ,COD_CARGOBASICO
        ,TIP_PLANTARIF
        ,TIP_UNIDADES
        ,NUM_UNIDADES
        ,IND_ARRASTRE
        ,NUM_DIAS
        ,NUM_ABONADOS
        ,TO_CHAR (FEC_DESDE,'YYYYMMDDHH24MISS')
        ,TO_CHAR (FEC_HASTA,'YYYYMMDDHH24MISS')
        ,IND_FRANCONS
    FROM
    TA_PLANTARIF;

    EXEC SQL OPEN CGePlanTarif;

    return sqlca.sqlcode;
}
/******************************************************************************
Funcion         :       ifnOraDeclararGePenalizaciones
*******************************************************************************/

int ifnOraDeclararGePenalizaciones (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGePenalizaciones CURSOR FOR
    SELECT
        ROWID
        ,COD_CLIENTE
        ,TIP_INCIDENCIA
        ,TO_CHAR (FEC_EFECTIVIDAD,'YYYYMMDDHH24MISS')
        ,COD_MONEDA
        ,IMP_PENALIZ
        ,COD_CICLFACT
        ,COD_CONCEPTO
        ,COD_PRODUCTO
        ,NUM_ABONADO
        ,NUM_PROCESO
    FROM
    CA_PENALIZACIONES;

    EXEC SQL OPEN CGePenalizaciones;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeCatImpClientes
*******************************************************************************/

int ifnOraDeclararGeCatImpClientes (sql_context ctx,char *szFecha,long ciclo, long ci, long cf)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

        EXEC SQL BEGIN DECLARE SECTION;
    static char* szhFecha   ; EXEC SQL VAR szhFecha         IS STRING(15);
    static long  lCodCiclo  ;
    static long  lhClieIni  ;
    static long  lhClieFin  ;
    int          ihCero  = 0;
    EXEC SQL END DECLARE SECTION;

        szhFecha        = szFecha       ;
        lCodCiclo   = ciclo     ;
        lhClieIni   = ci        ;
        lhClieFin   = cf        ;
        ihpUno      = 1;
        if (lhClieFin!=0)
        {
        EXEC SQL DECLARE CGeCatImpClientesR CURSOR FOR

                SELECT /*+ index (GE_CATIMPCLIENTES PK_GE_CATIMPCLIENTES) */
                  A.COD_CLIENTE   ,
                  A.COD_CATIMPOS  ,
                  TO_CHAR (FA_SEQ_IND_ORDENTOTAL.NEXTVAL)
            FROM GE_CATIMPCLIENTES A,
                 (SELECT DISTINCT COD_CLIENTE
                  FROM FA_CICLOCLI
                  WHERE NUM_PROCESO = :ihCero
                  AND   IND_MASCARA = :ihpUno
                  AND   COD_CICLO = :lCodCiclo
                  AND   COD_CLIENTE >= :lhClieIni
                  AND   COD_CLIENTE <= :lhClieFin) CLI
            WHERE A.COD_CLIENTE = CLI.COD_CLIENTE
            AND A.FEC_DESDE <= TO_DATE (:szhFecha,'YYYYMMDDHH24MISS')
            AND A.FEC_HASTA >= TO_DATE (:szhFecha,'YYYYMMDDHH24MISS');

        EXEC SQL OPEN CGeCatImpClientesR;
    }
    else
    {
        EXEC SQL DECLARE CGeCatImpClientes CURSOR FOR

        SELECT /*+ index (GE_CATIMPCLIENTES PK_GE_CATIMPCLIENTES) */
                A.COD_CLIENTE   ,
                    A.COD_CATIMPOS  ,
                    TO_CHAR (FA_SEQ_IND_ORDENTOTAL.NEXTVAL)
            FROM GE_CATIMPCLIENTES A,
                 (SELECT DISTINCT COD_CLIENTE
                  FROM   FA_CICLOCLI
                  WHERE  NUM_PROCESO = :ihCero
                  AND    IND_MASCARA = :ihpUno
                  AND    COD_CICLO   = :lCodCiclo) CLI
            WHERE A.COD_CLIENTE = CLI.COD_CLIENTE
            AND A.FEC_DESDE <= TO_DATE (:szhFecha,'YYYYMMDDHH24MISS')
            AND A.FEC_HASTA >= TO_DATE (:szhFecha,'YYYYMMDDHH24MISS');

        EXEC SQL OPEN CGeCatImpClientes;
    }
    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraDeclararGeDirecciones
*******************************************************************************/

int ifnOraDeclararGeDirecciones (sql_context ctx,int iTipDireccion,long ciclo, long ci, long cf)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL BEGIN DECLARE SECTION;
    static short ihCodTipDireccion;
    static long  lCodCiclo  ;
    static long  lhClieIni  ;
    static long  lhClieFin  ;
    int     ihCero = 0;
    EXEC SQL END DECLARE SECTION  ;

        lCodCiclo   = ciclo     ;
        lhClieIni   = ci        ;
        lhClieFin   = cf        ;
    ihCodTipDireccion  = iTipDireccion;
    ihpUno = 1;
    if (lhClieFin!=0)
    {
		EXEC SQL DECLARE CGeDireccionesR CURSOR FOR
	        SELECT /*+ index (GA_DIRECCLI PK_GA_DIRECCLI) */
	        DISTINCT
	               B.COD_CLIENTE  ,
	               A.COD_REGION   ,
	               A.COD_PROVINCIA,
	               A.COD_CIUDAD   ,
	               A.COD_COMUNA   ,
	               A.NOM_CALLE    ,
	               A.NUM_CALLE    ,
	               A.NUM_PISO
	        FROM  GE_DIRECCIONES A, GA_DIRECCLI B, FA_CICLOCLI C 
	        WHERE B.COD_TIPDIRECCION = :ihCodTipDireccion
	        AND   B.COD_DIRECCION    = A.COD_DIRECCION
	        AND   C.COD_CLIENTE 	  = B.COD_CLIENTE 
		AND   C.num_proceso	  = :ihCero
		AND   C.ind_mascara	  = :ihpUno
		AND   C.cod_ciclo 	  = :lCodCiclo 
		AND   C.COD_CLIENTE 	 >= :lhClieIni 
		AND   C.COD_CLIENTE 	 <= :lhClieFin;	 

            EXEC SQL OPEN CGeDireccionesR;
    }
    else
    {
		EXEC SQL DECLARE CGeDirecciones CURSOR FOR
	        SELECT /*+ index (GA_DIRECCLI PK_GA_DIRECCLI) */
	        DISTINCT
	               B.COD_CLIENTE  ,
	               A.COD_REGION   ,
	               A.COD_PROVINCIA,
	               A.COD_CIUDAD   ,
	               A.COD_COMUNA   ,
	               A.NOM_CALLE    ,
	               A.NUM_CALLE    ,
	               A.NUM_PISO
	        FROM   GE_DIRECCIONES A, GA_DIRECCLI B, FA_CICLOCLI C
	        WHERE  B.COD_CLIENTE = C.COD_CLIENTE 
	          AND  C.NUM_PROCESO = :ihCero 
	          AND  C.IND_MASCARA = :ihpUno
	          AND  C.COD_CICLO=:lCodCiclo
	          AND  B.COD_TIPDIRECCION = :ihCodTipDireccion
	          AND  B.COD_DIRECCION    = A.COD_DIRECCION;

        EXEC SQL OPEN CGeDirecciones;
    }
    return sqlca.sqlcode;

}

/*********************************************************************3*********
Funcion     :       ifnOraDeclararGeDirecciones2
*******************************************************************************/

int ifnOraDeclararGeDirecciones2 (sql_context ctx,int iTipDireccion,long ciclo, long ci, long cf)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL BEGIN DECLARE SECTION;
    static short ihCodTipDireccion;
    static long  lCodCiclo  ;
    static long  lhClieIni  ;
    static long  lhClieFin  ;
    int     ihCero = 0;
    EXEC SQL END DECLARE SECTION  ;

        lCodCiclo   = ciclo     ;
        lhClieIni   = ci        ;
        lhClieFin   = cf        ;
    ihCodTipDireccion  = iTipDireccion;
    ihpUno = 1;
        if (lhClieFin!=0)
        {
		EXEC SQL DECLARE CGeDireccionesR2 CURSOR FOR
	        SELECT /*+ index (GA_DIRECCLI PK_GA_DIRECCLI) */
	        DISTINCT
	               B.COD_CLIENTE  ,
	               A.COD_REGION   ,
	               A.COD_PROVINCIA,
	               A.COD_CIUDAD   ,
	               A.COD_COMUNA   ,
	               A.NOM_CALLE    ,
	               A.NUM_CALLE    ,
	               A.NUM_PISO
	        FROM  GE_DIRECCIONES A, GA_DIRECCLI B, FA_CICLOCLI C 
	        WHERE B.COD_TIPDIRECCION = :ihCodTipDireccion
	        AND   B.COD_DIRECCION    = A.COD_DIRECCION
	        AND   C.COD_CLIENTE 	  = B.COD_CLIENTE 
		AND   C.num_proceso	  = :ihCero
		AND   C.ind_mascara	  = :ihpUno
		AND   C.cod_ciclo 	  = :lCodCiclo 
		AND   C.COD_CLIENTE 	 >= :lhClieIni 
		AND   C.COD_CLIENTE 	 <= :lhClieFin;	 

            EXEC SQL OPEN CGeDireccionesR2;
    }
    else
    {
	        EXEC SQL DECLARE CGeDirecciones2 CURSOR FOR
	        SELECT /*+ index (GA_DIRECCLI PK_GA_DIRECCLI) */
	        DISTINCT
	               B.COD_CLIENTE  ,
	               A.COD_REGION   ,
	               A.COD_PROVINCIA,
	               A.COD_CIUDAD   ,
	               A.COD_COMUNA   ,
	               A.NOM_CALLE    ,
	               A.NUM_CALLE    ,
	               A.NUM_PISO
	        FROM   GE_DIRECCIONES A, GA_DIRECCLI B, FA_CICLOCLI C
	        WHERE  B.COD_CLIENTE = C.COD_CLIENTE 
	          AND  C.NUM_PROCESO = :ihCero 
	          AND  C.IND_MASCARA = :ihpUno
	          AND  C.COD_CICLO=:lCodCiclo
	          AND  B.COD_TIPDIRECCION = :ihCodTipDireccion
	          AND  B.COD_DIRECCION    = A.COD_DIRECCION;


        EXEC SQL OPEN CGeDirecciones2;
    }
    return sqlca.sqlcode;

}
/******************************************************************************
Funcion     :       ifnOraDeclararGeCoUnipac
*******************************************************************************/

int ifnOraDeclararGeCoUnipac (sql_context ctx,long ciclo, long ci, long cf)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL BEGIN DECLARE SECTION;
    static long  lCodCiclo  ;
    static long  lhClieIni  ;
    static long  lhClieFin  ;
    int    ihCero = 0;
    EXEC SQL END DECLARE SECTION  ;

    lCodCiclo   = ciclo     ;
    lhClieIni   = ci        ;
    lhClieFin   = cf        ;
    ihpUno = 1;
    if (lhClieFin!=0)
    {
        EXEC SQL DECLARE CGeCoUnipacR CURSOR FOR
        SELECT  DISTINCT
            PAC.COD_CLIENTE,
            PAC.COD_BANCO
            FROM CO_UNIPAC PAC, FA_CICLOCLI CLI
            WHERE PAC.COD_CLIENTE = CLI.COD_CLIENTE
           AND CLI.NUM_PROCESO = :ihCero
           AND CLI.IND_MASCARA = :ihpUno
           AND CLI.COD_CICLO   = :lCodCiclo
           AND CLI.COD_CLIENTE>= :lhClieIni AND CLI.COD_CLIENTE<=:lhClieFin;

            EXEC SQL OPEN CGeCoUnipacR;
    }
    else
    {
        EXEC SQL DECLARE CGeCoUnipac CURSOR FOR
        SELECT  DISTINCT
            PAC.COD_CLIENTE,
            PAC.COD_BANCO
            FROM CO_UNIPAC PAC,  FA_CICLOCLI CLI
            WHERE PAC.COD_CLIENTE = CLI.COD_CLIENTE
           AND CLI.NUM_PROCESO = :ihCero
           AND CLI.IND_MASCARA = :ihpUno
           AND CLI.COD_CICLO   = :lCodCiclo;

            EXEC SQL OPEN CGeCoUnipac;
    }
    return sqlca.sqlcode;

}

/********************************************************
    INICIO NUEVAS ESTRUCTURAS HOMOLOGADO
********************************************************/

/******************************************************************************
Funcion         :       ifnOraDeclararGeOficina
*******************************************************************************/

int ifnOraDeclararGeOficina (sql_context ctx)
{
    struct sqlca sqlca;
    EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeOficina CURSOR FOR
            SELECT /*+ USE_NL(B A) */
                A.COD_OFICINA,
                B.COD_REGION,
                B.COD_PROVINCIA,
                B.COD_CIUDAD,
                C.COD_PLAZA
                FROM
                GE_OFICINAS    A,
                GE_DIRECCIONES B,
                GE_CIUDADES    C
         WHERE A.COD_DIRECCION  = B.COD_DIRECCION
           AND B.COD_REGION     = C.COD_REGION
           AND B.COD_PROVINCIA  = C.COD_PROVINCIA
           AND B.COD_CIUDAD     = C.COD_CIUDAD;


        EXEC SQL OPEN CGeOficina;

    return sqlca.sqlcode;
}


/******************************************************************************
Funcion         :       ifnOraDeclararGeFactCobr
*******************************************************************************/

int ifnOraDeclararGeFactCobr (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL DECLARE CGeFactCobr CURSOR FOR

        SELECT
            COD_CONCFACT, COD_CONCCOBR
        FROM
        FA_FACTCOBR;

        EXEC SQL OPEN CGeFactCobr;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararDetPlanDesc
*******************************************************************************/

int ifnOraDeclararDetPlanDesc (sql_context ctx, long plCodCiclfact)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL BEGIN DECLARE SECTION;
        char  szhFmtFecha    [17];EXEC SQL VAR szhFmtFecha IS STRING(17);
        long  lhCodCiclFact  = 0L;
    EXEC SQL END DECLARE SECTION;

    strcpy (szhFmtFecha, "yyyymmddhh24miss");
    lhCodCiclFact = plCodCiclfact;

    EXEC SQL DECLARE Cur_DetPlanDesc CURSOR FOR
        SELECT B.COD_PLANDESC     ,
               B.DES_PLANDESC     ,
               TO_CHAR(B.FEC_DESDE,:szhFmtFecha),
               TO_CHAR(B.FEC_HASTA,:szhFmtFecha),
               B.IND_RESTRICCION  ,
               TO_CHAR(C.FEC_DESDE,:szhFmtFecha),
               TO_CHAR(C.FEC_HASTA,:szhFmtFecha),
               C.COD_TIPEVAL      ,
               C.COD_TIPAPLI      ,
               C.COD_GRUPOEVAL    ,
               C.COD_GRUPOAPLI    ,
               C.NUM_CUADRANTE    ,
               C.TIP_UNIDAD       ,
               C.COD_CONCDESC     ,
               C.MTO_MINFACT
          FROM FAD_PLANDESC B,  FAD_DETPLANDESC C, FA_CICLFACT A
         WHERE B.COD_PLANDESC = C.COD_PLANDESC
           AND A.COD_CICLFACT = :lhCodCiclFact
           AND A.FEC_EMISION BETWEEN C.FEC_DESDE AND C.FEC_HASTA;

        EXEC SQL OPEN Cur_DetPlanDesc;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararDescCargPunt
*******************************************************************************/

int ifnOraDeclararDescCargPunt (sql_context ctx,long ciclo)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL BEGIN DECLARE SECTION;
        static long  lCodCiclo  ;
        int     ihCero = 0;
        int     ihUNO  = 1;
		int     ihTRES = 3;
    EXEC SQL END DECLARE SECTION;

    lCodCiclo = ciclo;

    EXEC SQL DECLARE Cur_DescCargPunt CURSOR FOR
     SELECT DES.COD_CLIENTE,
	       DES.NUM_ABONADO,
	       TO_NUMBER (DES.TIP_DESCUENTO),
	       DES.COD_CONCEPTO,
	       DES.COD_CONCDESC,
	       DES.MTO_DESCUENTO,
	       0,
	       DES.ROWID
	  FROM FA_DESC_PUNTUAL_TO DES
	 WHERE EXISTS (SELECT 1
	                 FROM FA_CICLOCLI CLI
	                WHERE CLI.COD_CICLO = :lCodCiclo
	                  AND CLI.NUM_PROCESO = :ihCero
	                  AND CLI.IND_MASCARA = :ihUNO
	                  AND EXISTS (SELECT 1
	                                FROM GE_CLIENTES CLIE
	                               WHERE  CLIE.COD_CLIENTE = CLI.COD_CLIENTE
	                               AND (CLIE.FEC_BAJA IS NULL OR SYSDATE < CLIE.FEC_BAJA )) /* LIA - 21-03-2012 - 182208 - SE SACA LA VALIDACION DEL COD_CICLO DE LA GE_CLIENTES */
	                  AND CLI.COD_CLIENTE = DES.COD_CLIENTE
	                  AND (CLI.NUM_ABONADO = DES.NUM_ABONADO OR DES.NUM_ABONADO = :ihCero))
	AND DES.IND_ORDENTOTAL = :ihCero
	AND DES.TIP_DESCUENTO IN (:ihUNO,:ihTRES)
	ORDER BY DES.COD_CLIENTE;

    EXEC SQL OPEN Cur_DescCargPunt;

    return sqlca.sqlcode;
}



/********************************************************
    FIN NUEVAS ESTRUCTURAS HOMOLOGADO
********************************************************/

/******************************************************************************
Funcion     :       vfnImpErrorORACLE
*******************************************************************************/

void vfnImpErrorORACLE(sql_context ctx)
{

    fprintf(stderr,"\n\t%s\n", sqlca.sqlerrm.sqlerrmc);
}

/******************************************************************************
Funcion     :       ifnOraLeerFacClientes
*******************************************************************************/

int ifnOraLeerFacClientes(FAC_CLIENTES_HOST *pstHost,long *plNumFilas,
                  sql_context ctx,long clieini,long cliefin,FAC_CLIENTES_HOST_NULL *pstHostNull)
{
        struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

        EXEC SQL VAR pstHost->szNomCliente  IS STRING (51);
        EXEC SQL VAR pstHost->szNomApeClien1    IS STRING (21);
        EXEC SQL VAR pstHost->szNomApeClien2    IS STRING (21);
        EXEC SQL VAR pstHost->szTefCliente1     IS STRING (16);
        EXEC SQL VAR pstHost->szTefCliente2     IS STRING (16);
        EXEC SQL VAR pstHost->szCodPais     IS STRING (4);
        EXEC SQL VAR pstHost->szIndDebito   IS STRING (2);
        EXEC SQL VAR pstHost->szCodBanco    IS STRING (16);
        EXEC SQL VAR pstHost->szCodSucursal     IS STRING (5);
        EXEC SQL VAR pstHost->szIndTipCuenta    IS STRING (2);
        EXEC SQL VAR pstHost->szCodTipTarjeta   IS STRING (4);
        EXEC SQL VAR pstHost->szNumCtaCorr  IS STRING (19);
        EXEC SQL VAR pstHost->szNumTarjeta  IS STRING (19);
        EXEC SQL VAR pstHost->szFecVenciTarj    IS STRING (15);
        EXEC SQL VAR pstHost->szCodBancoTarj    IS STRING (16);
        EXEC SQL VAR pstHost->szCodTipIdTrib    IS STRING (3);
        EXEC SQL VAR pstHost->szNumIdentTrib    IS STRING (21);
        EXEC SQL VAR pstHost->szCodOficina  IS STRING (3);
        EXEC SQL VAR pstHost->szNumFax      IS STRING (16);
        EXEC SQL VAR pstHost->szFecAlta     IS STRING (15);
        EXEC SQL VAR pstHost->szCodIdioma   IS STRING (6);
        EXEC SQL VAR pstHost->szCodOperadora    IS STRING (6);

    if(cliefin!=0)
    {
        EXEC SQL FETCH CFacClientesR
                INTO    :pstHost->lCodCliente                   ,
                        :pstHost->szNomCliente                      ,
                        :pstHost->szNomApeClien1:pstHostNull->sszNomApeClien1   ,
                        :pstHost->szNomApeClien2:pstHostNull->sszNomApeClien2   ,
                        :pstHost->szTefCliente1:pstHostNull->sszTefCliente1     ,
                        :pstHost->szTefCliente2:pstHostNull->sszTefCliente2     ,
                        :pstHost->szCodPais:pstHostNull->sszCodPais             ,
                        :pstHost->szIndDebito:pstHostNull->sszIndDebito         ,
                        :pstHost->dImpStopDebit:pstHostNull->sdImpStopDebit     ,
                        :pstHost->szCodBanco:pstHostNull->sszCodBanco           ,
                        :pstHost->szCodSucursal:pstHostNull->sszCodSucursal     ,
                        :pstHost->szIndTipCuenta:pstHostNull->sszIndTipCuenta   ,
                        :pstHost->szCodTipTarjeta:pstHostNull->sszCodTipTarjeta ,
                        :pstHost->szNumCtaCorr:pstHostNull->sszNumCtaCorr       ,
                        :pstHost->szNumTarjeta:pstHostNull->sszNumTarjeta       ,
                        :pstHost->szFecVenciTarj:pstHostNull->sszFecVenciTarj   ,
                        :pstHost->szCodBancoTarj:pstHostNull->sszCodBancoTarj   ,
                        :pstHost->szCodTipIdTrib:pstHostNull->sszCodTipIdTrib   ,
                        :pstHost->szNumIdentTrib:pstHostNull->sszNumIdentTrib   ,
                        :pstHost->iCodActividad:pstHostNull->siCodActividad     ,
                        :pstHost->szCodOficina:pstHostNull->sszCodOficina       ,
                        :pstHost->iIndFactur                                ,
                        :pstHost->szNumFax:pstHostNull->sszNumFax               ,
                        :pstHost->szFecAlta                                 ,
                        :pstHost->lCodCuenta                                ,
                        :pstHost->szCodIdioma                               ,
                        :pstHost->szCodOperadora:pstHostNull->sszCodOperadora   ;

    }
    else
    {
        EXEC SQL FETCH CFacClientes
                INTO    :pstHost->lCodCliente                   ,
                        :pstHost->szNomCliente                      ,
                        :pstHost->szNomApeClien1:pstHostNull->sszNomApeClien1   ,
                        :pstHost->szNomApeClien2:pstHostNull->sszNomApeClien2   ,
                        :pstHost->szTefCliente1:pstHostNull->sszTefCliente1     ,
                        :pstHost->szTefCliente2:pstHostNull->sszTefCliente2     ,
                        :pstHost->szCodPais:pstHostNull->sszCodPais             ,
                        :pstHost->szIndDebito:pstHostNull->sszIndDebito         ,
                        :pstHost->dImpStopDebit:pstHostNull->sdImpStopDebit     ,
                        :pstHost->szCodBanco:pstHostNull->sszCodBanco           ,
                        :pstHost->szCodSucursal:pstHostNull->sszCodSucursal     ,
                        :pstHost->szIndTipCuenta:pstHostNull->sszIndTipCuenta   ,
                        :pstHost->szCodTipTarjeta:pstHostNull->sszCodTipTarjeta ,
                        :pstHost->szNumCtaCorr:pstHostNull->sszNumCtaCorr       ,
                        :pstHost->szNumTarjeta:pstHostNull->sszNumTarjeta       ,
                        :pstHost->szFecVenciTarj:pstHostNull->sszFecVenciTarj   ,
                        :pstHost->szCodBancoTarj:pstHostNull->sszCodBancoTarj   ,
                        :pstHost->szCodTipIdTrib:pstHostNull->sszCodTipIdTrib   ,
                        :pstHost->szNumIdentTrib:pstHostNull->sszNumIdentTrib   ,
                        :pstHost->iCodActividad:pstHostNull->siCodActividad     ,
                        :pstHost->szCodOficina:pstHostNull->sszCodOficina       ,
                        :pstHost->iIndFactur                                ,
                        :pstHost->szNumFax:pstHostNull->sszNumFax               ,
                        :pstHost->szFecAlta                                 ,
                        :pstHost->lCodCuenta                                ,
                        :pstHost->szCodIdioma                               ,
                        :pstHost->szCodOperadora:pstHostNull->sszCodOperadora   ;
    }

    if (sqlca.sqlcode==SQL_OK)
                *plNumFilas = TAM_HOST;
        else
                if (sqlca.sqlcode==NOT_FOUND)
                        *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

        return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerFacCiclo
*******************************************************************************/

int ifnOraLeerFacCiclo(FAC_CICLO_HOST *pstHostCiclo,FAC_CICLO_HOST_NULL *pstHostCicloNull,
                   long *plNumFilasCiclo,sql_context ctx,long clieini,long cliefin)
{
        struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

        EXEC SQL VAR pstHostCiclo->szRowid IS STRING(19);
        EXEC SQL VAR pstHostCiclo->szCodCalClien IS STRING(3);
        EXEC SQL VAR pstHostCiclo->szNomUsuario IS STRING(21);
        EXEC SQL VAR pstHostCiclo->szNomApellido1 IS STRING(21);
        EXEC SQL VAR pstHostCiclo->szNomApellido2 IS STRING(21);
        EXEC SQL VAR pstHostCiclo->szIndDebito IS STRING(2);
        EXEC SQL VAR pstHostCiclo->szFecAlta IS STRING(15);
        EXEC SQL VAR pstHostCiclo->szFecUltFact IS STRING(15);

    if(cliefin!=0)
    {
        EXEC SQL FETCH CFacCicloR
            INTO
                    :pstHostCiclo->szRowid,
                        :pstHostCiclo->lCodCliente,
                :pstHostCiclo->iCodProducto,
                    :pstHostCiclo->lNumAbonado,
                :pstHostCiclo->szCodCalClien,
                :pstHostCiclo->iIndCambio,
                :pstHostCiclo->szNomUsuario,
                :pstHostCiclo->szNomApellido1,
                :pstHostCiclo->szNomApellido2:pstHostCicloNull->sszNomApellido2,
                :pstHostCiclo->iCodCredMor:pstHostCicloNull->siCodCredMor,
                :pstHostCiclo->szIndDebito:pstHostCicloNull->sszIndDebito,
                :pstHostCiclo->iCodCicloNue:pstHostCicloNull->siCodCicloNue,
                :pstHostCiclo->szFecAlta,
                :pstHostCiclo->szFecUltFact;
    }
    else
    {
        EXEC SQL FETCH CFacCiclo
            INTO
                    :pstHostCiclo->szRowid,
                        :pstHostCiclo->lCodCliente,
                :pstHostCiclo->iCodProducto,
                    :pstHostCiclo->lNumAbonado,
                :pstHostCiclo->szCodCalClien,
                :pstHostCiclo->iIndCambio,
                :pstHostCiclo->szNomUsuario,
                :pstHostCiclo->szNomApellido1,
                :pstHostCiclo->szNomApellido2:pstHostCicloNull->sszNomApellido2,
                :pstHostCiclo->iCodCredMor:pstHostCicloNull->siCodCredMor,
                :pstHostCiclo->szIndDebito:pstHostCicloNull->sszIndDebito,
                :pstHostCiclo->iCodCicloNue:pstHostCicloNull->siCodCicloNue,
                :pstHostCiclo->szFecAlta,
                :pstHostCiclo->szFecUltFact;
    }

        if (sqlca.sqlcode==SQL_OK)
                *plNumFilasCiclo = TAM_HOST;
        else
                if (sqlca.sqlcode==NOT_FOUND)
                        *plNumFilasCiclo = sqlca.sqlerrd[2] % TAM_HOST;

        return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeCargos
*******************************************************************************/

int  ifnOraLeerGeCargos(CARGOS_HOST *pstHost,CARGOS_HOST_NULL *pstHostNull,long *plNumFilas,sql_context ctx,long ci, long cf)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szRowid       IS STRING(19);
    EXEC SQL VAR pstHost->szDesConcepto     IS STRING(61);
    EXEC SQL VAR pstHost->szFecAlta     IS STRING(15);
    EXEC SQL VAR pstHost->szCodMoneda   IS STRING(4);
    EXEC SQL VAR pstHost->szNumTerminal  IS STRING(16);
    EXEC SQL VAR pstHost->szNumSerie     IS STRING(26);
    EXEC SQL VAR pstHost->szNumSerieMec  IS STRING(26);
    EXEC SQL VAR pstHost->szNumPreGuia   IS STRING(11);
    EXEC SQL VAR pstHost->szNumGuia      IS STRING(11);
    EXEC SQL VAR pstHost->szCodRegion   IS STRING(4);
    EXEC SQL VAR pstHost->szCodProvincia    IS STRING(6);
    EXEC SQL VAR pstHost->szCodCiudad   IS STRING(6);
    EXEC SQL VAR pstHost->szCodCuota    IS STRING(3);
    EXEC SQL VAR pstHost->szCodModulo   IS STRING(3);
    EXEC SQL VAR pstHost->szCodTecnologia   IS STRING(8);

    if(cf!=0)
    {
        EXEC SQL FETCH CGeCargosR
            INTO
            :pstHost->szRowid                      ,
            :pstHost->lNumCargo                    ,
            :pstHost->lCodCliente                  ,
            :pstHost->iCodProducto                 ,
            :pstHost->iCodConcepto                 ,
            :pstHost->szFecAlta                    ,
            :pstHost->dImpCargo                    ,
            :pstHost->szCodMoneda                  ,
            :pstHost->lCodPlanCom                  ,
            :pstHost->lNumUnidades                 ,
            :pstHost->lNumAbonado:pstHostNull->slNumAbonado ,
            :pstHost->szNumTerminal:pstHostNull->sszNumTerminal ,
            :pstHost->lCodCiclFact:pstHostNull->slCodCiclFact    ,
            :pstHost->szNumSerie:pstHostNull->sszNumSerie   ,
            :pstHost->szNumSerieMec:pstHostNull->sszNumSerieMec ,
            :pstHost->lCapCode:pstHostNull->slCapCode           ,
            :pstHost->iMesGarantia:pstHostNull->siMesGarantia       ,
            :pstHost->szNumPreGuia:pstHostNull->sszNumPreGuia       ,
            :pstHost->szNumGuia:pstHostNull->sszNumGuia             ,
            :pstHost->lNumTransaccion:pstHostNull->slNumTransaccion     ,
            :pstHost->lNumVenta:pstHostNull->slNumTransaccion               ,
            :pstHost->lNumFactura:pstHostNull->slNumTransaccion             ,
            :pstHost->iCodConceptoDto:pstHostNull->siCodConceptoDto ,
            :pstHost->dValDto:pstHostNull->sdValDto                 ,
            :pstHost->iTipDto:pstHostNull->siTipDto                 ,
            :pstHost->iIndCuota:pstHostNull->siIndCuota             ,
            :pstHost->iNumPaquete:pstHostNull->siNumPaquete             ,
            :pstHost->iIndFactur                   ,
            :pstHost->iIndSuperTel:pstHostNull->siIndSuperTel       ;
    }
    else
    {
        EXEC SQL FETCH CGeCargos
            INTO
            :pstHost->szRowid                      ,
            :pstHost->lNumCargo                    ,
            :pstHost->lCodCliente                  ,
            :pstHost->iCodProducto                 ,
            :pstHost->iCodConcepto                 ,
            :pstHost->szFecAlta                    ,
            :pstHost->dImpCargo                    ,
            :pstHost->szCodMoneda                  ,
            :pstHost->lCodPlanCom                  ,
            :pstHost->lNumUnidades                 ,
            :pstHost->lNumAbonado:pstHostNull->slNumAbonado ,
            :pstHost->szNumTerminal:pstHostNull->sszNumTerminal ,
            :pstHost->lCodCiclFact:pstHostNull->slCodCiclFact    ,
            :pstHost->szNumSerie:pstHostNull->sszNumSerie   ,
            :pstHost->szNumSerieMec:pstHostNull->sszNumSerieMec ,
            :pstHost->lCapCode:pstHostNull->slCapCode           ,
            :pstHost->iMesGarantia:pstHostNull->siMesGarantia       ,
            :pstHost->szNumPreGuia:pstHostNull->sszNumPreGuia       ,
            :pstHost->szNumGuia:pstHostNull->sszNumGuia             ,
            :pstHost->lNumTransaccion:pstHostNull->slNumTransaccion     ,
            :pstHost->lNumVenta:pstHostNull->slNumTransaccion               ,
            :pstHost->lNumFactura:pstHostNull->slNumTransaccion             ,
            :pstHost->iCodConceptoDto:pstHostNull->siCodConceptoDto ,
            :pstHost->dValDto:pstHostNull->sdValDto                 ,
            :pstHost->iTipDto:pstHostNull->siTipDto                 ,
            :pstHost->iIndCuota:pstHostNull->siIndCuota             ,
            :pstHost->iNumPaquete:pstHostNull->siNumPaquete             ,
            :pstHost->iIndFactur                   ,
            :pstHost->iIndSuperTel:pstHostNull->siIndSuperTel       ;
    }


    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeCabCuotas
*******************************************************************************/

int  ifnOraLeerGeCabCuotas(CABCUOTAS_HOST *pstHost,CABCUOTAS_HOST_NULL *pstHostNull,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szRowid       IS STRING(19);
    EXEC SQL VAR pstHost->szDesConcepto     IS STRING(61);
    EXEC SQL VAR pstHost->szCodMoneda   IS STRING(4);
    EXEC SQL VAR pstHost->szCodCuota    IS STRING(3);
    EXEC SQL VAR pstHost->szCodModulo   IS STRING(3);


    EXEC SQL FETCH CGeCabCuotas
        INTO
        :pstHost->szRowid                   ,
        :pstHost->lSeqCuotas                ,
                :pstHost->lCodCliente               ,
                :pstHost->iCodConcepto              ,
                :pstHost->szCodMoneda               ,
                :pstHost->iCodProducto              ,
                :pstHost->iNumCuotas                ,
                :pstHost->dImpTotal                 ,
                :pstHost->iIndPagada                ,
                :pstHost->lNumAbonado           ,
                :pstHost->szCodCuota:pstHostNull->sszCodCuota       ,
                :pstHost->lNumPagare;


    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeTaConcepFact
*******************************************************************************/

int  ifnOraLeerGeTaConcepFact(TACONCEPFACT_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szCodServicio     IS STRING(6);

    EXEC SQL FETCH CGeTaConcepFact
        INTO
        :pstHost->iCodProducto    ,
                :pstHost->iCodFacturacion ,
                :pstHost->iIndTabla       ,
                :pstHost->iIndEntSal      ,
                :pstHost->iIndDestino     ,
                :pstHost->iCodTarificacion,
                :pstHost->szCodServicio    ;


    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeConceptos
*******************************************************************************/

int  ifnOraLeerGeConceptos(CONCEPTO_HOST *pstHost,CONCEPTO_HOST_NULL *pstHostNull,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;


    EXEC SQL VAR pstHost->szDesConcepto     IS STRING(61);
    EXEC SQL VAR pstHost->szCodModulo   IS STRING(3);
    EXEC SQL VAR pstHost->szCodMoneda   IS STRING(4);
    EXEC SQL VAR pstHost->szCodTipDescu     IS STRING(2);
    EXEC SQL VAR pstHost->szDefTecnologia   IS STRING(8);


    EXEC SQL FETCH CGeConceptos
        INTO
                 :pstHost->iCodConcepto,
                 :pstHost->iCodProducto,
                 :pstHost->szDesConcepto,
                 :pstHost->iCodTipConce,
                 :pstHost->szCodModulo,
                 :pstHost->szCodMoneda,
                 :pstHost->iIndActivo,
                 :pstHost->iCodConcOrig:pstHostNull->siCodConcOrig,
                 :pstHost->szCodTipDescu:pstHostNull->sszCodTipDescu,
                 :pstHost->sIndTecnologia,
                 :pstHost->szDefTecnologia,
                 :pstHost->iCodConCobr;


    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeConceptos_Mi
*******************************************************************************/

int  ifnOraLeerGeConceptos_Mi(CONCEPTO_MI_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

/*  EXEC SQL VAR pstHost->szCodConcepto     IS STRING(12);  */
    EXEC SQL VAR pstHost->szCodIdioma   IS STRING(6);
    EXEC SQL VAR pstHost->szDesConcepto     IS STRING(61);


    EXEC SQL FETCH CGeConceptos_Mi
        INTO
         :pstHost->iCodConcepto,
         :pstHost->szCodIdioma,
         :pstHost->szDesConcepto;



    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeRangoTabla
*******************************************************************************/

int  ifnOraLeerGeRangoTabla(RANGOTABLA_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szNomTabla    IS STRING(21);


    EXEC SQL FETCH CGeRangoTabla
        INTO
         :pstHost->lCodCiclFact,
         :pstHost->lRangoIni   ,
                 :pstHost->lRangoFin   ,
                 :pstHost->iCodProducto,
                 :pstHost->szNomTabla;


    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeLimCreditos
*******************************************************************************/

int  ifnOraLeerGeLimCreditos(LIMCREDITOS_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szRowid       IS STRING(19);
    EXEC SQL VAR pstHost->szCodCalClien IS STRING(3) ;
    EXEC SQL VAR pstHost->szDesCredMor  IS STRING(41);


    EXEC SQL FETCH CGeLimCreditos
        INTO
         :pstHost->szRowid      ,
                 :pstHost->iCodCredMor  ,
                 :pstHost->iCodProducto ,
                 :pstHost->szCodCalClien,
                 :pstHost->szDesCredMor ,
                 :pstHost->dImpMorosidad;


    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeActividades
*******************************************************************************/

int  ifnOraLeerGeActividades(ACTIVIDADES_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szRowid       IS STRING(19);
    EXEC SQL VAR pstHost->szDesActividad IS STRING(41);


    EXEC SQL FETCH CGeActividades
        INTO
         :pstHost->szRowid      ,
                 :pstHost->iCodActividad,
                 :pstHost->szDesActividad;



    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeProvincias
*******************************************************************************/

int  ifnOraLeerGeProvincias(PROVINCIAS_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szRowid       IS STRING(19);
    EXEC SQL VAR pstHost->szCodRegion IS STRING(4);
    EXEC SQL VAR pstHost->szCodProvincia IS STRING(6);
    EXEC SQL VAR pstHost->szDesProvincia IS STRING(31);

    EXEC SQL FETCH CGeProvincias
        INTO
        :pstHost->szRowid       ,
                :pstHost->szCodRegion   ,
                :pstHost->szCodProvincia,
                :pstHost->szDesProvincia;


    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeRegiones
*******************************************************************************/

int  ifnOraLeerGeRegiones(REGIONES_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szRowid       IS STRING(19);
    EXEC SQL VAR pstHost->szCodRegion IS STRING(4);
    EXEC SQL VAR pstHost->szDesRegion IS STRING(31);

    EXEC SQL FETCH CGeRegiones

        INTO
        :pstHost->szRowid       ,
                :pstHost->szCodRegion   ,
                :pstHost->szDesRegion;


    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeCatImpositiva
*******************************************************************************/

int  ifnOraLeerGeCatImpositiva(CATIMPOSITIVA_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szRowid       IS STRING(19);
    EXEC SQL VAR pstHost->szDesCatImpos IS STRING(41);

    EXEC SQL FETCH CGeCatImpositiva
        INTO :pstHost->szRowid        ,
             :pstHost->iCodCatImpos   ,
             :pstHost->szDesCatImpos  ;

    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeZonaCiudad
*******************************************************************************/

int  ifnOraLeerGeZonaCiudad(ZONACIUDAD_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szCodRegion     IS STRING(4) ;
    EXEC SQL VAR pstHost->szCodProvincia  IS STRING(6) ;
    EXEC SQL VAR pstHost->szCodCiudad     IS STRING(6) ;
    EXEC SQL VAR pstHost->szFecDesde      IS STRING(15);
    EXEC SQL VAR pstHost->szFecHasta      IS STRING(15);

    EXEC SQL FETCH CGeZonaCiudad
        INTO :pstHost->szCodRegion   ,
             :pstHost->szCodProvincia,
             :pstHost->szCodCiudad   ,
             :pstHost->szFecDesde    ,
             :pstHost->szFecHasta    ,
             :pstHost->iCodZonaImpo  ;


    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeZonaImpositiva
*******************************************************************************/

int  ifnOraLeerGeZonaImpositiva(ZONAIMPOSITIVA_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;


    EXEC SQL VAR pstHost->szRowid       IS STRING(19);
    EXEC SQL VAR pstHost->szDesZonaImpo     IS STRING(41) ;

    EXEC SQL FETCH CGeZonaImp
        INTO
         :pstHost->szRowid      ,
             :pstHost->iCodZonaImpo ,
             :pstHost->szDesZonaImpo;


    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeImpuestos
*******************************************************************************/

int  ifnOraLeerGeImpuestos(IMPUESTOS_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szRowid       IS STRING(19);
    EXEC SQL VAR pstHost->szFecDesde     IS STRING(15) ;
    EXEC SQL VAR pstHost->szFecHasta     IS STRING(15) ;

    EXEC SQL FETCH CGeImpuestos
        INTO
        :pstHost->szRowid      ,
        :pstHost->iCodCatImpos ,
                :pstHost->iCodZonaImpo ,
                :pstHost->iCodTipImpues,
                :pstHost->iCodGrpServi ,
                :pstHost->szFecDesde   ,
                :pstHost->iCodConcGene ,
                :pstHost->szFecHasta   ,
                :pstHost->fPrcImpuesto ;


    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeTipImpues
*******************************************************************************/

int  ifnOraLeerGeTipImpues(TIPIMPUES_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szRowid       IS STRING(19);
    EXEC SQL VAR pstHost->szDesTipImpue     IS STRING(41) ;


    EXEC SQL FETCH CGeTipImpues
        INTO
        :pstHost->szRowid      ,
        :pstHost->iCodTipImpue ,
                :pstHost->szDesTipImpue,
                :pstHost->dImpUmbral   ;


    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeGrpSerConc
*******************************************************************************/

int  ifnOraLeerGeGrpSerConc(GRPSERCONC_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szFecDesde    IS STRING(15) ;
    EXEC SQL VAR pstHost->szFecHasta    IS STRING(15) ;

    EXEC SQL FETCH CGeGrpSerConc
        INTO :pstHost->iCodConcepto,
             :pstHost->szFecDesde  ,
             :pstHost->iCodGrpServi,
             :pstHost->szFecHasta  ;

    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeConversion
*******************************************************************************/

int  ifnOraLeerGeConversion(CONVERSION_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szCodMoneda   IS STRING(4);
    EXEC SQL VAR pstHost->szFecDesde    IS STRING(15) ;
    EXEC SQL VAR pstHost->szFecHasta    IS STRING(15) ;

    EXEC SQL FETCH CGeConversion
        INTO :pstHost->szCodMoneda,
             :pstHost->szFecDesde  ,
             :pstHost->szFecHasta ,
             :pstHost->dCambio;

    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeDocumSucursal
*******************************************************************************/

int  ifnOraLeerGeDocumSucursal(DOCUMSUCURSAL_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szRowid       IS STRING(19);
    EXEC SQL VAR pstHost->szCodOficina  IS STRING(3);

    EXEC SQL FETCH CGeDocumSucursal
        INTO
         :pstHost->szRowid     ,
                 :pstHost->szCodOficina,
                 :pstHost->iCodTipDocum  ,
                 :pstHost->iCodCentrEmi;

    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeLetras
*******************************************************************************/

int  ifnOraLeerGeLetras(LETRAS_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szRowid       IS STRING(19);
    EXEC SQL VAR pstHost->szLetra  IS STRING(2);

    EXEC SQL FETCH CGeLetras
        INTO
         :pstHost->szRowid     ,
                 :pstHost->iCodTipDocum,
                 :pstHost->iCodCatImpos  ,
                 :pstHost->szLetra;

    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeGrupoCob
*******************************************************************************/

int ifnOraLeerGeGrupoCob (GRUPOCOB_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szCodGrupo  IS STRING(3);
    EXEC SQL VAR pstHost->szFecDesde    IS STRING(15) ;
    EXEC SQL VAR pstHost->szFecHasta    IS STRING(15) ;


    EXEC SQL FETCH CGeGrupoCob
        INTO :pstHost->szCodGrupo,
             :pstHost->iCodProducto  ,
             :pstHost->iCodConcepto  ,
             :pstHost->iTipCobro  ,
             :pstHost->szFecDesde  ,
             :pstHost->szFecHasta  ,
             :pstHost->iTipCobroAnt;

    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeTarifas
*******************************************************************************/

int  ifnOraLeerGeTarifas(TARIFAS_HOST *pstHost,TARIFAS_HOST_NULL *pstHostNull,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szCodTipServ   IS STRING(2) ;
    EXEC SQL VAR pstHost->szCodServicio  IS STRING(4) ;
    EXEC SQL VAR pstHost->szCodPlanServ  IS STRING(4) ;
    EXEC SQL VAR pstHost->szFecDesde    IS STRING(15) ;
    EXEC SQL VAR pstHost->szCodMoneda    IS STRING(4) ;
    EXEC SQL VAR pstHost->szIndPeriodico IS STRING(2) ;
    EXEC SQL VAR pstHost->szFecHasta     IS STRING(15);

    EXEC SQL FETCH CGeTarifas
        INTO :pstHost->szCodTipServ  ,
             :pstHost->szCodServicio  ,
             :pstHost->szCodPlanServ  ,
             :pstHost->szFecDesde  ,
             :pstHost->dImpTarifa  ,
             :pstHost->szCodMoneda  ,
             :pstHost->szIndPeriodico  ,
             :pstHost->szFecHasta:pstHostNull->sszFecHasta;

    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeActuaServ
*******************************************************************************/

int  ifnOraLeerGeActuaServ(ACTUASERV_HOST *pstHost,ACTUASERV_HOST_NULL *pstHostNull,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szCodTipServ   IS STRING(2) ;
    EXEC SQL VAR pstHost->szCodServicio  IS STRING(4) ;


    EXEC SQL FETCH CGeActuaServ
        INTO :pstHost->szCodTipServ  ,
             :pstHost->szCodServicio,
             :pstHost->iCodConcepto:pstHostNull->siCodConcepto;

    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeCuotas
*******************************************************************************/

int  ifnOraLeerGeCuotas(CUOTAS_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szRowid  IS STRING(19);
    EXEC SQL VAR pstHost->szFecEmision    IS STRING(15) ;

    EXEC SQL FETCH CGeCuotas
        INTO
         :pstHost->szRowid     ,
                 :pstHost->lSeqCuotas,
         :pstHost->iOrdCuota  ,
         :pstHost->szFecEmision  ,
         :pstHost->dImpCuota,
                 :pstHost->iIndFacturado,
                 :pstHost->iIndPagado;

    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeFactCarriers
*******************************************************************************/

int  ifnOraLeerGeFactCarriers(FACTCARRIERS_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL FETCH CGeFactCarriers
        INTO
         :pstHost->iCodConcFact   ,
                 :pstHost->iCodConcCarrier;


    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeCuadCtoPlan
*******************************************************************************/

int  ifnOraLeerGeCuadCtoPlan(CUADCTOPLAN_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szRowid  IS STRING(19);

    EXEC SQL FETCH CGeCuadCtoPlan
        INTO
         :pstHost->szRowid   ,
                 :pstHost->lCodCtoPlan,
         :pstHost->dImpUmbDesde   ,
                 :pstHost->dImpUmbHasta,
         :pstHost->dImpDescuento   ,
                 :pstHost->iCodTipoDto;


    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeCtoPlan
*******************************************************************************/

int  ifnOraLeerGeCtoPlan(CTOPLAN_HOST *pstHost,CTOPLAN_HOST_NULL *pstHostNull,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szRowid  IS STRING(19);
    EXEC SQL VAR pstHost->szCodTipCtoPlan IS STRING (2) ;
    EXEC SQL VAR pstHost->szCodMoneda     IS STRING (4) ;
    EXEC SQL VAR pstHost->szNomUsuario     IS STRING (31) ;

    EXEC SQL FETCH CGeCtoPlan
        INTO
         :pstHost->szRowid   ,
         :pstHost->lCodCtoPlan,
         :pstHost->iCodProducto   ,
         :pstHost->szCodTipCtoPlan,
         :pstHost->szCodMoneda   ,
         :pstHost->iCodCtoFac   ,
         :pstHost->dImpDescuento,
         :pstHost->iCodTipoDto   ,
         :pstHost->iIndCuadrante,
         :pstHost->iCodTipoCuad   ,
         :pstHost->szNomUsuario,
         :pstHost->dImpUmbDesde:pstHostNull->sdImpUmbDesde,
         :pstHost->dImpUmbHasta:pstHostNull->sdImpUmbHasta,
         :pstHost->iNumDias:pstHostNull->siNumDias;

    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGePlanCtoPlan
*******************************************************************************/

int  ifnOraLeerGePlanCtoPlan(PLANCTOPLAN_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szRowid  IS STRING(19);
    EXEC SQL VAR pstHost->szFecEfectividad IS STRING (15) ;
    EXEC SQL VAR pstHost->szFecFinEfectividad IS STRING (15) ;
    EXEC SQL VAR pstHost->szNomUsuario     IS STRING (31) ;

    EXEC SQL FETCH CGePlanCtoPlan
        INTO
         :pstHost->szRowid   ,
                 :pstHost->lCodPlanCom,
         :pstHost->iCodProducto   ,
                 :pstHost->lCodCtoPlan,
         :pstHost->szFecEfectividad   ,
                 :pstHost->szFecFinEfectividad   ,
                 :pstHost->szNomUsuario;


    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeArriendo
*******************************************************************************/

int  ifnOraLeerGeArriendo(ARRIENDO_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szRowid  IS STRING(19);
    EXEC SQL VAR pstHost->szFecDesde IS STRING (15) ;
    EXEC SQL VAR pstHost->szFecHasta IS STRING (15) ;
    EXEC SQL VAR pstHost->szCodMoneda IS STRING (4) ;


    EXEC SQL FETCH CGeArriendo
        INTO
         :pstHost->szRowid   ,
                 :pstHost->lCodCliente,
         :pstHost->lNumAbonado   ,
                 :pstHost->szFecDesde,
         :pstHost->szFecHasta  ,
                 :pstHost->iCodProducto   ,
                 :pstHost->iCodConcepto   ,
                 :pstHost->lCodArticulo   ,
                 :pstHost->dPrecioMes   ,
                 :pstHost->szCodMoneda;


    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeCargosBasico
*******************************************************************************/

int  ifnOraLeerGeCargosBasico(CARGOSBASICO_HOST *pstHost,CARGOSBASICO_HOST_NULL *pstHostNull,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szCodCargoBasico IS STRING(4) ;
    EXEC SQL VAR pstHost->szFecDesde       IS STRING(15);
    EXEC SQL VAR pstHost->szFecHasta       IS STRING(15);
    EXEC SQL VAR pstHost->szCodMoneda      IS STRING(4) ;

    EXEC SQL FETCH CGeCargosBasico
    INTO :pstHost->iCodProducto,
        :pstHost->szCodCargoBasico   ,
        :pstHost->szFecDesde  ,
        :pstHost->szFecHasta:pstHostNull->sszFecHasta   ,
        :pstHost->dImpCargoBasico   ,
        :pstHost->szCodMoneda;

    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeOptimo
*******************************************************************************/

int  ifnOraLeerGeOptimo(OPTIMO_HOST *pstHost,OPTIMO_HOST_NULL *pstHostNull,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szCodPlanTarif  IS STRING(4);

    EXEC SQL FETCH CGeOptimo
        INTO :pstHost->szCodPlanTarif   ,
             :pstHost->lMinDesde,
             :pstHost->lMinHasta:pstHostNull->slMinHasta   ,
             :pstHost->fPrcAbono,
             :pstHost->fPrcNormal  ,
             :pstHost->fPrcBajo ;

    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeFeriados
*******************************************************************************/

int  ifnOraLeerGeFeriados(FERIADOS_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szFecFeriado  IS STRING(15);

    EXEC SQL FETCH CGeFeriados
        INTO
         :pstHost->szFecFeriado;


    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGePlanTarif
*******************************************************************************/

int  ifnOraLeerGePlanTarif(PLANTARIF_HOST *pstHost,PLANTARIF_HOST_NULL *pstHostNull,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szCodPlanTarif    IS STRING(4) ;
    EXEC SQL VAR pstHost->szTipTerminal     IS STRING(2) ;
    EXEC SQL VAR pstHost->szCodLimConsumo   IS STRING(4) ;
    EXEC SQL VAR pstHost->szCodCargoBasico  IS STRING(4) ;
    EXEC SQL VAR pstHost->szCodMoneda       IS STRING(4) ;
    EXEC SQL VAR pstHost->szTipPlanTarif    IS STRING(2) ;
    EXEC SQL VAR pstHost->szCod_Unidad      IS STRING(6) ;
    EXEC SQL VAR pstHost->szFecDesde        IS STRING(15);
    EXEC SQL VAR pstHost->szFecHasta        IS STRING(15);
    EXEC SQL VAR pstHost->szInd_Francons    IS STRING(3);

    EXEC SQL FETCH CGePlanTarif
        INTO :pstHost->iCodProducto,
             :pstHost->szCodPlanTarif,
             :pstHost->szTipTerminal:pstHostNull->sszTipTerminal,
             :pstHost->szCodLimConsumo,
             :pstHost->szCodCargoBasico,
             :pstHost->szTipPlanTarif,
             :pstHost->szCod_Unidad,
             :pstHost->lNumUnidades,
             :pstHost->iIndArrastre,
             :pstHost->iNumDias,
             :pstHost->lNumAbonados:pstHostNull->slNumAbonados,
             :pstHost->szFecDesde,
             :pstHost->szFecHasta:pstHostNull->sszFecHasta,
             :pstHost->szInd_Francons;

    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGePenalizaciones
*******************************************************************************/

int  ifnOraLeerGePenalizaciones(PENALIZA_HOST *pstHost,PENALIZA_HOST_NULL *pstHostNull,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szRowid  IS STRING(19);
    EXEC SQL VAR pstHost->szFecEfectividad  IS STRING(15);
    EXEC SQL VAR pstHost->szCodMoneda  IS STRING(4);

    EXEC SQL FETCH CGePenalizaciones
        INTO
         :pstHost->szRowid,
                 :pstHost->lCodCliente,
                 :pstHost->iTipIncidencia,
                 :pstHost->szFecEfectividad,
                 :pstHost->szCodMoneda,
                 :pstHost->dImpPenaliz,
                 :pstHost->lCodCiclFact:pstHostNull->slCodCiclFact,
                 :pstHost->iCodConcepto,
                 :pstHost->iCodProducto,
                 :pstHost->lNumAbonado:pstHostNull->slNumAbonado,
                 :pstHost->lNumProceso;


    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeCatImpClientes
*******************************************************************************/

int  ifnOraLeerGeCatImpClientes(CAT_IMPCLIENTES_HOST *pstHost,long *plNumFilas,sql_context ctx,long clieini,long cliefin)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szIndOrdenTotal IS STRING(13);

    if (cliefin !=0)
    {
        EXEC SQL FETCH CGeCatImpClientesR
        INTO
             :pstHost->lCodCliente,
             :pstHost->iCodCatImpos,
                     :pstHost->szIndOrdenTotal;
        }
        else
        {
            EXEC SQL FETCH CGeCatImpClientes
        INTO
             :pstHost->lCodCliente,
             :pstHost->iCodCatImpos,
                         :pstHost->szIndOrdenTotal;
        }

    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeDirecciones
*******************************************************************************/

int  ifnOraLeerGeDirecciones(DIRECCIONES_HOST *pstHost,DIRECCIONES_HOST_NULL *pstHostNull,long *plNumFilas,sql_context ctx,
                long clieini,long cliefin)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szCodRegion IS STRING(4);
    EXEC SQL VAR pstHost->szCodProvincia IS STRING(6);
    EXEC SQL VAR pstHost->szCodCiudad IS STRING(6);
    EXEC SQL VAR pstHost->szCodComuna IS STRING(6);
    EXEC SQL VAR pstHost->szNomCalle IS STRING(51);
    EXEC SQL VAR pstHost->szNumCalle IS STRING(11);
    EXEC SQL VAR pstHost->szNumPiso IS STRING(11);

        if (cliefin !=0)
    {
        EXEC SQL FETCH CGeDireccionesR
        INTO
            :pstHost->lCodCliente,
            :pstHost->szCodRegion             ,
            :pstHost->szCodProvincia          ,
            :pstHost->szCodCiudad             ,
            :pstHost->szCodComuna             ,
            :pstHost->szNomCalle :pstHostNull->sszNomCalle,
            :pstHost->szNumCalle :pstHostNull->sszNumCalle,
            :pstHost->szNumPiso  :pstHostNull->sszNumPiso;
        }
        else
        {
        EXEC SQL FETCH CGeDirecciones
        INTO
            :pstHost->lCodCliente,
            :pstHost->szCodRegion             ,
            :pstHost->szCodProvincia          ,
            :pstHost->szCodCiudad             ,
            :pstHost->szCodComuna             ,
            :pstHost->szNomCalle :pstHostNull->sszNomCalle,
            :pstHost->szNumCalle :pstHostNull->sszNumCalle,
            :pstHost->szNumPiso  :pstHostNull->sszNumPiso;
        }

    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeDirecciones2
*******************************************************************************/

int  ifnOraLeerGeDirecciones2(DIRECCIONES_HOST2 *pstHost,DIRECCIONES_HOST_NULL2 *pstHostNull,long *plNumFilas,sql_context ctx,
                long clieini,long cliefin)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szCodRegion IS STRING(4);
    EXEC SQL VAR pstHost->szCodProvincia IS STRING(6);
    EXEC SQL VAR pstHost->szCodCiudad IS STRING(6);
    EXEC SQL VAR pstHost->szCodComuna IS STRING(6);
    EXEC SQL VAR pstHost->szNomCalle IS STRING(51);
    EXEC SQL VAR pstHost->szNumCalle IS STRING(11);
    EXEC SQL VAR pstHost->szNumPiso IS STRING(11);

        if (cliefin !=0)
    {
        EXEC SQL FETCH CGeDireccionesR2
        INTO
            :pstHost->lCodCliente,
            :pstHost->szCodRegion             ,
                    :pstHost->szCodProvincia          ,
                    :pstHost->szCodCiudad             ,
                    :pstHost->szCodComuna             ,
                    :pstHost->szNomCalle :pstHostNull->sszNomCalle,
                    :pstHost->szNumCalle :pstHostNull->sszNumCalle,
                    :pstHost->szNumPiso  :pstHostNull->sszNumPiso;
        }
        else
        {
        EXEC SQL FETCH CGeDirecciones2
        INTO
            :pstHost->lCodCliente,
            :pstHost->szCodRegion             ,
                    :pstHost->szCodProvincia          ,
                    :pstHost->szCodCiudad             ,
                    :pstHost->szCodComuna             ,
                    :pstHost->szNomCalle :pstHostNull->sszNomCalle,
                    :pstHost->szNumCalle :pstHostNull->sszNumCalle,
                    :pstHost->szNumPiso  :pstHostNull->sszNumPiso;
        }

    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeCoUnipac
*******************************************************************************/

int  ifnOraLeerGeCoUnipac(UNIPAC_HOST *pstHost,long *plNumFilas,sql_context ctx,long clieini,long cliefin)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    if (cliefin !=0)
    {
        EXEC SQL FETCH CGeCoUnipacR
        INTO
            :pstHost->lCodCliente,
            :pstHost->szCodBanco;
        }
        else
        {
        EXEC SQL FETCH CGeCoUnipac
        INTO
            :pstHost->lCodCliente,
            :pstHost->szCodBanco;
        }

    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/********************************************************
    INICIO NUEVAS ESTRUCTURAS HOMOLOGADO
********************************************************/

/******************************************************************************
Funcion     :       ifnOraLeerGeOficina
*******************************************************************************/

int  ifnOraLeerGeOficina(OFICINA_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szCodOficina      IS STRING (3) ;
    EXEC SQL VAR pstHost->szCodRegion       IS STRING (4) ;
    EXEC SQL VAR pstHost->szCodProvincia    IS STRING (6) ;
    EXEC SQL VAR pstHost->szCodCiudad       IS STRING (6) ;
    EXEC SQL VAR pstHost->szCodPlaza        IS STRING (6) ;

    EXEC SQL FETCH CGeOficina
        INTO
        :pstHost->szCodOficina  ,
        :pstHost->szCodRegion   ,
        :pstHost->szCodProvincia,
        :pstHost->szCodCiudad   ,
        :pstHost->szCodPlaza    ;

    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeFactCobr
*******************************************************************************/

int  ifnOraLeerGeFactCobr(FACTCOBR_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL FETCH CGeFactCobr
        INTO
        :pstHost->iCodConcFact,
        :pstHost->iCodConCobr;

    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}


/******************************************************************************
Funcion     :       ifnOraLeerDetPlanDesc
*******************************************************************************/

int  ifnOraLeerDetPlanDesc(DETPLANDESC_HOST *pstHost,DETPLANDESC_HOST_NULL *pstHostNull, long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szCodPlan             IS STRING (6) ;
    EXEC SQL VAR pstHost->szDesPlandesc         IS STRING (31);
    EXEC SQL VAR pstHost->szFecDesdePlandesc    IS STRING (15);
    EXEC SQL VAR pstHost->szFecHastaPlandesc    IS STRING (15);
    EXEC SQL VAR pstHost->szIndRestriccion      IS STRING (2) ;
    EXEC SQL VAR pstHost->szFecDesdeDetplan     IS STRING (15);
    EXEC SQL VAR pstHost->szFecHastaDetplan     IS STRING (15);
    EXEC SQL VAR pstHost->szCodTipeval          IS STRING (2) ;
    EXEC SQL VAR pstHost->szCodTipapli          IS STRING (2) ;
    EXEC SQL VAR pstHost->szTipUnidad           IS STRING (3) ;

    EXEC SQL FETCH Cur_DetPlanDesc
              INTO :pstHost->szCodPlan ,
                   :pstHost->szDesPlandesc      ,
                   :pstHost->szFecDesdePlandesc ,
                   :pstHost->szFecHastaPlandesc ,
                   :pstHost->szIndRestriccion   ,
                   :pstHost->szFecDesdeDetplan  ,
                   :pstHost->szFecHastaDetplan  ,
                   :pstHost->szCodTipeval       ,
                   :pstHost->szCodTipapli       ,
                   :pstHost->iCodGrupoeval :pstHostNull->i_shCodGrupoeval ,
                   :pstHost->iCodGrupoapli :pstHostNull->i_shCodGrupoapli  ,
                   :pstHost->iNumCuadrante :pstHostNull->i_shNumCuadrante ,
                   :pstHost->szTipUnidad        ,
                   :pstHost->iCodConcdesc   :pstHostNull->i_shCodConcdesc ,
                   :pstHost->dMtoMinfact    :pstHostNull->i_shMtoMinfact ;

    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}


/********************************************************
    FIN NUEVAS ESTRUCTURAS HOMOLOGADO
********************************************************/

/******************************************************************************
Funcion     :       ifnOraCerrarFacClientes
*******************************************************************************/

int ifnOraCerrarFacClientes(sql_context ctx, long clieini, long cliefin)
{
        struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    if(cliefin!=0)
    {
        EXEC SQL CLOSE CFacClientesR;
    }
    else
    {
        EXEC SQL CLOSE CFacClientes;
    }

        return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarFacCiclo
*******************************************************************************/

int ifnOraCerrarFacCiclo(sql_context ctx, long clieini, long cliefin)
{
        struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    if(cliefin!=0)
    {
        EXEC SQL CLOSE CFacCicloR;
    }
    else
    {
        EXEC SQL CLOSE CFacCiclo;
    }

        return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeCargos
*******************************************************************************/

int ifnOraCerrarGeCargos(sql_context ctx,long ci,long cf)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    if(cf!=0)
    {
        EXEC SQL CLOSE CGeCargosR;
    }
    else
    {
        EXEC SQL CLOSE CGeCargos;
    }

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeCabCuotas
*******************************************************************************/

int ifnOraCerrarGeCabCuotas (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeCabCuotas;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeTaConcepFact
*******************************************************************************/

int ifnOraCerrarGeTaConcepFact (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeTaConcepFact;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeConceptos
*******************************************************************************/

int ifnOraCerrarGeConceptos (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeConceptos;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeConceptos_Mi
*******************************************************************************/

int ifnOraCerrarGeConceptos_Mi (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeConceptos_Mi;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeRangoTabla
*******************************************************************************/

int ifnOraCerrarGeRangoTabla (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeRangoTabla;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeLimCreditos
*******************************************************************************/

int ifnOraCerrarGeLimCreditos (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeLimCreditos;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeActividades
*******************************************************************************/

int ifnOraCerrarGeActividades (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeActividades;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeProvincias
*******************************************************************************/

int ifnOraCerrarGeProvincias (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeProvincias;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeRegiones
*******************************************************************************/

int ifnOraCerrarGeRegiones (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeRegiones;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeCatImpositiva
*******************************************************************************/

int ifnOraCerrarGeCatImpositiva (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeCatImpositiva;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeZonaCiudad
*******************************************************************************/

int ifnOraCerrarGeZonaCiudad (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeZonaCiudad;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeZonaImpositiva
*******************************************************************************/

int ifnOraCerrarGeZonaImpositiva (sql_context ctx)
{
    /*struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeZonaImp;

    return sqlca.sqlcode;*/
    return 0;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeImpuestos
*******************************************************************************/

int ifnOraCerrarGeImpuestos (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeImpuestos;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeTipImpues
*******************************************************************************/

int ifnOraCerrarGeTipImpues (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeTipImpues;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeGrpSerConc
*******************************************************************************/

int ifnOraCerrarGeGrpSerConc (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeGrpSerConc;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeConversion
*******************************************************************************/

int ifnOraCerrarGeConversion (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeConversion;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeDocumSucursal
*******************************************************************************/

int ifnOraCerrarGeDocumSucursal (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeDocumSucursal;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeLetras
*******************************************************************************/

int ifnOraCerrarGeLetras (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeLetras;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeGrupoCob
*******************************************************************************/

int ifnOraCerrarGeGrupoCob (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeGrupoCob;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeTarifas
*******************************************************************************/

int ifnOraCerrarGeTarifas (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeTarifas;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeActuaServ
*******************************************************************************/

int ifnOraCerrarGeActuaServ (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeActuaServ;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeCuotas
*******************************************************************************/

int ifnOraCerrarGeCuotas (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeCuotas;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeFactCarriers
*******************************************************************************/

int ifnOraCerrarGeFactCarriers (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeFactCarriers;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeCuadCtoPlan
*******************************************************************************/

int ifnOraCerrarGeCuadCtoPlan (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeCuadCtoPlan;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeCtoPlan
*******************************************************************************/

int ifnOraCerrarGeCtoPlan (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeCtoPlan;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGePlanCtoPlan
*******************************************************************************/

int ifnOraCerrarGePlanCtoPlan (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGePlanCtoPlan;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeArriendo
*******************************************************************************/

int ifnOraCerrarGeArriendo (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeArriendo;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeCargosBasico
*******************************************************************************/

int ifnOraCerrarGeCargosBasico (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeCargosBasico;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeOptimo
*******************************************************************************/

int ifnOraCerrarGeOptimo (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeOptimo;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeFeriados
*******************************************************************************/

int ifnOraCerrarGeFeriados (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeFeriados;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGePlanTarif
*******************************************************************************/

int ifnOraCerrarGePlanTarif (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGePlanTarif;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGePenalizaciones
*******************************************************************************/

int ifnOraCerrarGePenalizaciones (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGePenalizaciones;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeCatImpClientes
*******************************************************************************/

int  ifnOraCerrarGeCatImpClientes(sql_context ctx,long clieini,long cliefin)

{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    if(cliefin!=0)
    {
        EXEC SQL CLOSE CGeCatImpClientesR;
    }
    else
    {
        EXEC SQL CLOSE CGeCatImpClientes;
    }

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeDirecciones
*******************************************************************************/

int ifnOraCerrarGeDirecciones (sql_context ctx,long clieini,long cliefin)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    if(cliefin!=0)
    {
        EXEC SQL CLOSE CGeDireccionesR;
    }
    else
    {
        EXEC SQL CLOSE CGeDirecciones;
    }

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeDirecciones2
*******************************************************************************/

int ifnOraCerrarGeDirecciones2 (sql_context ctx,long clieini,long cliefin)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    if(cliefin!=0)
    {
        EXEC SQL CLOSE CGeDireccionesR2;
    }
    else
    {
        EXEC SQL CLOSE CGeDirecciones2;
    }

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeCoUnipac
*******************************************************************************/

int ifnOraCerrarGeCoUnipac (sql_context ctx,long clieini,long cliefin)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    if(cliefin!=0)
    {
        EXEC SQL CLOSE CGeCoUnipacR;
    }
    else
    {
        EXEC SQL CLOSE CGeCoUnipac;
    }

    return sqlca.sqlcode;
}

/********************************************************
    INICIO NUEVAS ESTRUCTURAS HOMOLOGADO
********************************************************/

/******************************************************************************
Funcion     :       ifnOraCerrarGeOficina
*******************************************************************************/

int ifnOraCerrarGeOficina (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeOficina;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeFactCobr
*******************************************************************************/

int ifnOraCerrarGeFactCobr (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeFactCobr;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarDetPlanDesc
*******************************************************************************/

int ifnOraCerrarDetPlanDesc (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE Cur_DetPlanDesc;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeCargosBasico
*******************************************************************************/

int ifnOraCerrarDescPuntuales (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE Cur_DescCargPunt;

    return sqlca.sqlcode;
}

/********************************************************
    FIN NUEVAS ESTRUCTURAS HOMOLOGADO
********************************************************/

/******************************************************************************
Funcion     :       ifnOraContarPlaza
*******************************************************************************/
int ifnOraContarPlaza (int *iNumPlaza,sql_context ctx)
{
    struct sqlca sqlca;
    EXEC SQL CONTEXT USE :ctx;
    EXEC SQL BEGIN DECLARE SECTION;
        int icontador = 0;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL
        SELECT COUNT(DISTINCT COD_PLAZA)
          INTO :icontador
          FROM GE_CIUDADES;

    if (sqlca.sqlcode < 0)
    {
        fprintf(stdout,"\n [ifnOraContarPlaza]sqlca.sqlcode  ==>[%d] \n",sqlca.sqlcode);
        return sqlca.sqlcode;
    }
    if (icontador==0)
    {
        fprintf(stdout,"\n [ifnOraContarPlaza] NO EXISTE COD_PLAZA EN LA GE_CIUDADES \n");
        return FALSE;
    }

    if (sqlca.sqlcode == 0)
        *iNumPlaza=icontador;
    else
       *iNumPlaza = 0 ;

   return sqlca.sqlcode;
}

/******************************************************************************
Funcion         :       ifnOraDeclararGeOficina2
*******************************************************************************/

int ifnOraDeclararGeOficina2 (sql_context ctx)
{
    struct sqlca sqlca;
    EXEC SQL CONTEXT USE :ctx;

    EXEC SQL BEGIN DECLARE SECTION;
        char szhCodPlaza   [6]; EXEC SQL VAR szhCodPlaza IS STRING(6);
        EXEC SQL END DECLARE SECTION;

      EXEC SQL
          SELECT DISTINCT COD_PLAZA
           INTO :szhCodPlaza
          FROM GE_CIUDADES;

       EXEC SQL DECLARE CGeOficina2 CURSOR FOR
                SELECT
                 A.COD_OFICINA ,
                 B.COD_REGION ,
                 B.COD_PROVINCIA ,
                 B.COD_CIUDAD ,
                 :szhCodPlaza
                FROM
                 GE_DIRECCIONES B ,
                 GE_OFICINAS A
                WHERE A.COD_DIRECCION=B.COD_DIRECCION;


        EXEC SQL OPEN CGeOficina2;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerGeOficina2
*******************************************************************************/

int  ifnOraLeerGeOficina2(OFICINA_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szCodOficina      IS STRING (3) ;
    EXEC SQL VAR pstHost->szCodRegion       IS STRING (4) ;
    EXEC SQL VAR pstHost->szCodProvincia    IS STRING (6) ;
    EXEC SQL VAR pstHost->szCodCiudad       IS STRING (6) ;
    EXEC SQL VAR pstHost->szCodPlaza        IS STRING (6) ;

    EXEC SQL FETCH CGeOficina2
        INTO
        :pstHost->szCodOficina  ,
        :pstHost->szCodRegion   ,
        :pstHost->szCodProvincia,
        :pstHost->szCodCiudad   ,
        :pstHost->szCodPlaza    ;

    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraLeerDescCargPunt
*******************************************************************************/

int  ifnOraLeerDescCargPunt(DETCARG_PUNTUALES_HOST *pstHost,long *plNumFilas,sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL VAR pstHost->szRowid IS STRING(19);

    EXEC SQL FETCH Cur_DescCargPunt
        INTO
        :pstHost->lCodCliente             ,
        :pstHost->lNumAbonado             ,
                :pstHost->iCodTipDescu            ,
                :pstHost->lCodConcCargo           ,
                :pstHost->lCodConcDesc            ,
                :pstHost->dMtoDcto                ,
                :pstHost->dMtoAplicado        ,
                :pstHost->szRowid;

    if (sqlca.sqlcode==SQL_OK)
        *plNumFilas = TAM_HOST;
    else
        if (sqlca.sqlcode==NOT_FOUND)
            *plNumFilas = sqlca.sqlerrd[2] % TAM_HOST;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCerrarGeOficina2
*******************************************************************************/

int ifnOraCerrarGeOficina2 (sql_context ctx)
{
    struct sqlca sqlca;
        EXEC SQL CONTEXT USE :ctx;

    EXEC SQL CLOSE CGeOficina2;

    return sqlca.sqlcode;
}

/******************************************************************************
Funcion     :       ifnOraCuentaConcep
*******************************************************************************/
int ifnOraCuentaConcep (sql_context ctx, long *lCantConc)
{
    struct sqlca sqlca;
    EXEC SQL CONTEXT USE :ctx;

    EXEC SQL BEGIN DECLARE SECTION;
        long lhCantConc = 0;
    EXEC SQL END DECLARE SECTION;

      EXEC SQL
          SELECT MAX (COD_CONCEPTO)+1
	        INTO :lhCantConc
	        FROM FA_CONCEPTOS A, FA_FACTCOBR B
	       WHERE A.COD_CONCEPTO = B.COD_CONCFACT;
           /*AND A.COD_PRODUCTO = 1;*/

    *lCantConc = lhCantConc;
    return sqlca.sqlcode;
}


