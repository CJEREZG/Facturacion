/***************************************************************************/
/* Programa para detectar ausencia de registros en tabla GA_INTARCEL       */      
/* Por William Sepulveda V.                                                */
/*-------------------------------------------------------------------------*/
/* Version 1 - Revision 00  ("kore.pc")                                    */
/* 18 de enero de 1999.                                                    */
/*-------------------------------------------------------------------------*/
/* Version 1 - Revision 10  ("intarcel.pc")                                */
/* 18 de marzo de 1999.	                                                   */
/*                                                                         */
/* - Se ajusta a estructura estandar de directorios.                       */
/*-------------------------------------------------------------------------*/
/* Version 2 - Revision 00                                                 */
/* Jueves 22 de abril de 1999.                                             */
/*                                                                         */
/* - Se agregan rutinas para determinar informacion de tabla FA_CICLFACT   */
/* - Se disminuye la cantidad de argumentos recibidos externamente         */
/* - Se realiza separacion de anomalias posibles (para una mejor           */
/*   identificacion)                                                       */
/* - Se hacen mas precisas las condiciones de anomalias y se aumentan en   */
/*   cuanto a cantidad                                                     */
/* - Se utiliza la tabla FA_CICLOCLI como universo de generacion de        */
/*   potenciales anomalias                                                 */
/* - Se detectan tambien las ausencias en tabla GA_INFACCEL                */
/*-------------------------------------------------------------------------*/
/* Version 3 - Revision 00                                                 */	
/* Viernes 30 de abril de 1999.                                            */
/*                                                                         */
/* - Se aumenta la cantidad de anomalias que detecta.                      */
/* - Los registros con ind_actuac=2 en tabla GA_INFACCEL (bajas) se        */
/*   marcan como anomalias.                                                */
/* - Se marcan diferenciadamente los abonados que tienen anomalias de      */
/*   aquellos que pertenecen a un cliente que tiene otros abonados con     */
/*   anomalias.                                                            */                  
/* - Cambia la filosofia de busqueda en tabla GA_INFACCEL, ya que ahora    */
/*   esta se lleva a memoria, con lo cual se trabaja a nivel de arrays.    */
/* - Cambian los accesos a la tabla FA_CICLOCLI, para realizar los         */
/*   updates: Ahora se hace por rowid.                                     */
/* - Se detectan y marcan los abonados celulares y beeper que estan en     */
/*   situacion de baja en la tabla GA_ABOCEL/GA_ABOBEEP.                   */
/* - Se hacen todas las detecciones tambien para beeper                    */
/*-------------------------------------------------------------------------*/
/* Version 3 - Revision 10                                                 */
/* Miercoles 05 de mayo de 1999.                                           */
/*                                                                         */
/* - Se detectan y marcan (con -95) los abonados dados de alta con         */
/*   posterioridad a la fecha de termino del periodo.                      */
/*-------------------------------------------------------------------------*/
/* Version 3 - Revision 20                                                 */
/* Martes 18 de mayo de 1999.                                              */
/*                                                                         */
/* - Se modifica query sobre tablas GA_ABOCEL y GA_ABOBEEP, a fin de       */
/*   validar que la fecha de baja sea menor que la fecha de corte          */
/*   superior del periodo.                                                 */
/*-------------------------------------------------------------------------*/
/* Version 3 - Revision 30                                                 */
/* Lunes 24 de mayo de 1999.                                               */
/*                                                                         */
/* - Se incorpora la sentencia de alteracion del formato de fechas, para   */
/*   contemplar manejo de hora, minuto y segundo.                          */
/*-------------------------------------------------------------------------*/
/* Version 4 - Revision 00                                                 */
/* Jueves 22 de julio de 1999.                                             */
/*                                                                         */
/* - Cambia de nombre y pasa a llamarse "check_interfaz.pc".               */
/* - Se modifica la rutina de conexion a Oracle, pasando a usarse ahora la */
/*   funcion de conexion definida en "geora" (fnOraConnect).               */
/* - Se separa la rutina de despliegue de fecha y hora, colocandose en un  */
/*   archivo de rutinas utilitarias ("utils.c").                           */
/* - Se modifica rutina de configuracion de ambiente (ahora es mas         */
/*   robusta).                                                             */
/* - Las definiciones generales se trasladan a un archivo "prefac.h".      */
/* - Se incorporan todas las modificaciones relativas al tratamiento de    */
/*   los abonados de baja, para que estos sean facturados en el proceso de */
/*   facturacion de ciclo.                                                 */
/* - Paulatinamente voy adhiriendo a un estandar de nombres de variables.  */
/*-------------------------------------------------------------------------*/
/* Version 4 - Revision 10                                                 */
/* Jueves 30 de septiembre de 1999.                                        */
/*                                                                         */
/* - Para el caso de las empresas (o clientes con plan familiar), se       */
/*   realizara la validacion de existencia del abonado 0 en GA_INTARCEL    */
/*   solo cuando no exista registro en GA_INFACCEL, para ese abonado, en   */
/*   el periodo considerado (la cual es, en definitiva, la condicion que   */
/*   se valida para facturar o no al cliente).                             */
/*-------------------------------------------------------------------------*/
/* Version 4 - Revision 20                                                 */
/* Jueves 04 de noviembre de 1999.                                         */
/*                                                                         */
/* - Se incorpora hint en acceso a tabla GA_ABOCEL (query para obtener las */
/*   bajas), con el objetivo de mejorar el tiempo de respuesta total de    */
/*   ese query para prevenir caidas por snapshot too old.                  */
/*-------------------------------------------------------------------------*/
/* Version 4 - Revision 21                                                 */
/* Viernes 07 de enero de 2000.                                            */
/*                                                                         */
/* - Se modifica (corrige) el retorno de la busqueda en ga_infaccel (beep) */
/*   para el caso de bajas que ya no se replican. Antes se estaba          */
/*   considerando un retorno OK, pero debe ser un retorno ANOM99, que      */
/*   corresponde a una baja definitiva.                                    */
/*-------------------------------------------------------------------------*/
/* Version 4 - Revision 22                                                 */
/* Jueves 13  de enero de 2000.                                            */
/*                                                                         */
/* - Se modifica (corrige) el update sobre la tabla FA_CICLOCLI cuando     */
/*   el abonado esta dado de baja (ANOM98 en FA_CICLOCLI) y ya no se       */
/*   replica en la tabla de interfaz.                                      */
/*-------------------------------------------------------------------------*/
/* Version 4 - Revision 23                                                 */
/* Jueves 20  de enero de 2000.                                            */
/*                                                                         */
/* - Se modifica (corrige) el update sobre la tabla FA_CICLOCLI para el    */
/*   resto de los abonados de un cliente que tiena abonados con bajas      */
/*   definitivas (ya no se marcaran con anomalias -77).                    */
/*-------------------------------------------------------------------------*/
/* Version 4 - Revision 24                                                 */
/* Viernes 03 de marzo del 2000.                                           */
/*                                                                         */
/* - Se valida que el cliente de un abonado 0 tenga al menos 1 abonado     */
/*   activo en ga_infaccel para el periodo especificado. Si no hay         */
/*   activos, el cliente se considera baja definitiva (ANOM99).            */
/***************************************************************************/

/*************************************************************************/
/* SAAM-20030725 Se cambia logica de manejo de arreglos por TDA          */
/*************************************************************************/

#include "prefac.h"

#define VERSION  "1.006" 


/*---------------------------------------------------------------------------*/
/* Inclusion de biblioteca para manejo de interaccion con Oracle.            */
/*---------------------------------------------------------------------------*/
EXEC SQL INCLUDE sqlca;

#define MAX_BEEP      70000

/*---------------------------------------------------------------------------*/
/* Definicion de variables globales para ser usadas con Oracle.              */
/*---------------------------------------------------------------------------*/
EXEC SQL BEGIN DECLARE SECTION;
     rg_fa_ciclocli  *pstfa_ciclocli_primero;
     rg_fa_ciclocli  *pstfa_ciclocli_ultimo;
     rg_fa_ciclocli  *pstfa_ciclocli_posicion_aux=NULL;
     rg_ga_infaccel  *pstga_infaccel_primero;
     rg_ga_infaccel  *pstga_infaccel_ultimo;
     rg_ga_infaccel  *pstga_infaccel_posicion_aux=NULL;
     rg_ga_infacbeep  *pstga_infacbeep_primero;
     rg_ga_infacbeep  *pstga_infacbeep_ultimo;
     rg_ga_infacbeep  *pstga_infacbeep_posicion_aux=NULL;
     rg_fa_ciclfact	*fa_ciclfact;
     int   cliente_infac     [MAX_BUFF];
     int   abonado_infac     [MAX_BUFF];
     int   ind_actuac        [MAX_BUFF];
     int   ind_cuencontrolada[MAX_BUFF];
     short indic_cc          [MAX_BUFF];
     int   ind_cargopro      [MAX_BUFF];
     short indic_cp          [MAX_BUFF];
     int   cliente_beep      [MAX_BEEP];
     int   abonado_beep      [MAX_BEEP];
     int   ind_actuac_beep   [MAX_BEEP];
     int   ind_cargopro_beep [MAX_BEEP];
     short indic_cp_beep     [MAX_BEEP];
     char  abocel_fecbaja    [MAX_BUFF][15];
     char  abobeep_fecbaja   [MAX_BUFF][15];
     char  szTipParametro    [33]  = "";
     char  szValParametro    [512] = "";     
EXEC SQL END DECLARE SECTION;

/*---------------------------------------------------------------------------*/
/* Definicion de variables globales.                                         */
/*---------------------------------------------------------------------------*/
char   file_anom[1000];
int    anom10=0, anom11=0, anom12=0, anom13=0, anom14=0, anom15=0, anom16=0;
int    anom40=0, anom41=0, anom42=0, anom43=0, anom44=0, anom45=0, anom77=0;
int    ret_infac[MAX_BUFF];

static BOOL checkFactActual (long lCodCliente, long lCodCiclFact, BOOL *bClieconFact);
int    ifnCheckCargos       (long lCodCliente, long lCodCiclFact);


/********************************************************************************************/
void vSqlError ()
{
    EXEC SQL WHENEVER SQLERROR CONTINUE;

    vFechaHora();
    fprintf(stderr, "Error en ORACLE: \n%s\n"
                    "Proceso finalizado con error.\n", sqlca.sqlerrm.sqlerrmc);

    EXEC SQL ROLLBACK WORK RELEASE;
    exit(1);
}
/********************************************************************************************/
void vConfig_Ambiente ()
{
    char *path_dir;
    char dat_dir[1000];


    if((path_dir=getenv("DAT")) == NULL)
    {
        fprintf(stderr, "\nVariable de ambiente [DAT] no esta definida. Se cancela.\n");
        exit(2);
    }

    
    sprintf(dat_dir, "%.*s/%d",strlen(path_dir), path_dir, cod_ciclfact);

    fprintf(stderr, "dat_dir  :[%s]\n",dat_dir);

    sprintf(file_anom, "%.*s/anom_interfaz_%d.dat",strlen(dat_dir),dat_dir, cod_ciclfact);

    if(mkdir(dat_dir, S_IRWXU|S_IRWXG|S_IRWXO) == FAILURE)
    {
       if(errno != EEXIST)
       {
          fprintf(stderr, "Fallo la creacion del directorio [%s].\n", dat_dir);
          fprintf(stderr, "Error Numero: %d     %s\n", errno, strerror(errno));
          fprintf(stderr, "Proceso finalizado con error.\n");
          exit(2);
       }
    }
}
/********************************************************************************************/

FILE *Abre_Arch (char *ptr, char *modo)
{
    FILE *fp;

    if((fp=fopen(ptr, modo)) == NULL)
    {
        fprintf(stderr, "\nArchivo [%s] no pudo ser abierto.\n", ptr);
        fprintf(stderr, "Revise su existencia.\n");
        fprintf(stderr, "Error Numero: %d     %s\n", errno, strerror(errno));
        fprintf(stderr, "Proceso finalizado con error.\n");
        exit(2);
    }

    return(fp);
}
/********************************************************************************************/

void vInit_Variables ()
{
    rg_fa_ciclocli  *p;

    for(p = pstfa_ciclocli_primero;p != NULL;p = p->sigte) 
        free(p);

    pstfa_ciclocli_primero = NULL;
    pstfa_ciclocli_ultimo = NULL;
}
/************************************************************************************/
/*int iCheckCuotas(long lCodCliente) INC000000014051
{
    EXEC SQL BEGIN DECLARE SECTION  ;
         int ihCuota;
         int giMinNumCuotas = 0;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL
         SELECT  COUNT(1)
         INTO    :ihCuota
         FROM    CO_CARTERA CC
         WHERE   CC.COD_CLIENTE = :lCodCliente
         AND     CC.NUM_CUOTA   > :giMinNumCuotas
         AND     CC.COD_TIPDOCUM != 5
         AND     CC.COD_TIPDOCUM != 59
         AND     CC.COD_TIPDOCUM != 60
         AND     CC.COD_TIPDOCUM != 39
         AND     CC.COD_TIPDOCUM != 32
         AND     EXISTS (SELECT 1 FROM FA_CONCEPTOS_FACTURACION_VW FCF, FA_FACTCOBR FFC
                         WHERE FFC.COD_CONCCOBR = CC.COD_CONCEPTO
                         AND FCF.COD_CONCEPTO = FFC.COD_CONCFACT);

    if(SQLCODE != SQLOK && SQLCODE != SQLNOTFOUND)
    {
        fprintf(stderr,"\n\t** Error en Checkeo de cuotas en CO_CARTERA ** "
                                    "\n\t\t\t=>  Cliente    [%ld] "
                                    "\n\t\t\t=>  Errror     [%d] [%s]"
                                    ,lCodCliente,SQLCODE,SQLERRM);
        fprintf(stderr, "\n\t** Error en Checkeo de cuotas en CO_CARTERA ** "
                                    "\n\t\t\t=>  Cliente    [%ld] "
                                    "\n\t\t\t=>  Errror     [%d] [%s]"
                                    ,lCodCliente,SQLCODE,SQLERRM);
        return (-1);
    }
return (ihCuota);
}*/

void vBusca_FaCiclFact ()
{
    fa_ciclfact = (rg_fa_ciclfact *)malloc(sizeof(rg_fa_ciclfact));

    EXEC SQL 
         SELECT COD_CICLO, FEC_DESDELLAM, FEC_HASTALLAM
         INTO :fa_ciclfact
         FROM FA_CICLFACT
         WHERE COD_CICLFACT = :cod_ciclfact;

    if(sqlca.sqlcode < SQLOK)
    {
       vSqlError();
    }
  
    if(sqlca.sqlcode == SQLNOTFOUND)
    {
       fprintf(stderr, "No se ha encontrado informacion para el periodo en tabla FA_CICLFACT.\n");
       fprintf(stderr, "Proceso se cancela.\n");
       exit(3);
    }
}

/********************************************************************************************/
int iBuscaBajas_Beep ()
{
    rg_fa_ciclocli  *pstfa_ciclocli_nuevo;
    int         i;
    long        lLastRows    = 0;
    long        lFetchedRows = 10000;
    long        lRetrievRows = 10000;
    long        lCantidad       = 0;

    EXEC SQL BEGIN DECLARE SECTION;
         char szRowid[MAXFETCH][19];
         long lhCodCliente[MAXFETCH];
         long lhNumAbonado[MAXFETCH];
         long lhNUmProceso[MAXFETCH];
         int  iIndGravedad[MAXFETCH];
         int  iPosEmpresa[MAXFETCH];
         char szFecBaja[MAXFETCH][15];
    EXEC SQL END DECLARE SECTION;

    fprintf(stderr,"\n\t iBuscaBajas_Beep \n");
    vFechaHora();

    EXEC SQL DECLARE cursor_bajas_beep CURSOR FOR
         SELECT A.ROWID, A.COD_CLIENTE, A.NUM_ABONADO,  A.NUM_PROCESO,0,0, B.FEC_BAJA
         FROM FA_CICLOCLI A, GA_ABOBEEP B  
         WHERE A.COD_CICLO  = :fa_ciclfact->cod_ciclo
         AND A.NUM_PROCESO  = 0
         AND A.COD_PRODUCTO = 2
         AND A.FEC_ALTA    <= :fa_ciclfact->fec_hasta  
         AND B.NUM_ABONADO  = A.NUM_ABONADO
         AND B.COD_CLIENTE  = A.COD_CLIENTE
         AND B.COD_SITUACION IN ('BAA', 'BAP')
         AND B.FEC_BAJA    <= :fa_ciclfact->fec_hasta
         ORDER BY A.COD_CLIENTE, A.NUM_ABONADO;

    EXEC SQL OPEN cursor_bajas_beep;

    while(lFetchedRows == lRetrievRows)
    {
          EXEC SQL FETCH cursor_bajas_beep INTO :szRowid,:lhCodCliente,:lhNumAbonado,:lhNUmProceso,:iIndGravedad,:iPosEmpresa ,:szFecBaja;

          lRetrievRows = sqlca.sqlerrd[2] - lLastRows;
          lLastRows = sqlca.sqlerrd[2];

          for (i=0; i < lRetrievRows; i++) 
          {
               pstfa_ciclocli_nuevo = (rg_fa_ciclocli *) malloc (sizeof(rg_fa_ciclocli));

               if (pstfa_ciclocli_nuevo == NULL) 
               {
                   fprintf(stderr,"\tFalla en la asignacion de memoria en RG_FA_CICLOCLI BAJAS BEEP\n");
                   exit(1);
               }

               strcpy(pstfa_ciclocli_nuevo->rowid , szRowid[i]);
               pstfa_ciclocli_nuevo->cod_cliente  = lhCodCliente[i];
               pstfa_ciclocli_nuevo->num_abonado  = lhNumAbonado[i];
               pstfa_ciclocli_nuevo->cod_producto = 2;
               pstfa_ciclocli_nuevo->num_proceso  = lhNUmProceso[i];
               pstfa_ciclocli_nuevo->ind_gravedad = iIndGravedad[i];
               pstfa_ciclocli_nuevo->pos_empresa  = iPosEmpresa[i];
               strcpy(pstfa_ciclocli_nuevo->fec_baja , szFecBaja[i]);
               pstfa_ciclocli_nuevo->sigte = NULL;

               if (pstfa_ciclocli_primero==NULL)
               {
                   pstfa_ciclocli_primero = pstfa_ciclocli_nuevo;
                   pstfa_ciclocli_ultimo = pstfa_ciclocli_nuevo;
               }
               else 
               {
                   pstfa_ciclocli_ultimo->sigte = pstfa_ciclocli_nuevo;
                   pstfa_ciclocli_ultimo = pstfa_ciclocli_nuevo;
               }
               lCantidad++;
          }
    }
    
    EXEC SQL CLOSE cursor_bajas_beep;
    
    return(lCantidad-1);
}

/********************************************************************************************/
int iBuscaBajas_Cel ()
{
    rg_fa_ciclocli  *pstfa_ciclocli_nuevo;

    int         i;
    long        lLastRows    = 0;
    long        lFetchedRows = 10000;
    long        lRetrievRows = 10000;
    long        lCantidad       = 0;

    EXEC SQL BEGIN DECLARE SECTION;
         char szRowid[MAXFETCH][19];
         long lhCodCliente[MAXFETCH];
         long lhNumAbonado[MAXFETCH];
         char szFecBaja[MAXFETCH][15];
    EXEC SQL END DECLARE SECTION;

    fprintf(stderr,"\n\t iBuscaBajas_Cel \n");
    vFechaHora();

    EXEC SQL DECLARE cursor_bajas_cel CURSOR FOR
         SELECT /*+ index(B, PK_GA_ABOCEL) */
                A.ROWID, A.COD_CLIENTE, A.NUM_ABONADO, B.FEC_BAJA
         FROM FA_CICLOCLI A, GA_ABOCEL B  
         WHERE A.COD_CICLO  = :fa_ciclfact->cod_ciclo
         AND A.NUM_PROCESO  = 0
         AND A.COD_PRODUCTO = 1
         AND A.FEC_ALTA    <= :fa_ciclfact->fec_hasta  
         AND B.NUM_ABONADO  = A.NUM_ABONADO
         AND B.COD_CLIENTE  = A.COD_CLIENTE
         AND B.FEC_BAJA    <= :fa_ciclfact->fec_hasta
         AND B.COD_SITUACION IN ('BAA','BAP')
         AND   NOT EXISTS ( SELECT 1 FROM GA_EMPRESA C
                            WHERE C.COD_CICLO= :fa_ciclfact->cod_ciclo 
                            AND A.COD_CLIENTE=C.COD_CLIENTE)
         ORDER BY A.COD_CLIENTE, A.NUM_ABONADO;

    EXEC SQL OPEN cursor_bajas_cel;

    while(lFetchedRows == lRetrievRows)
    {
          EXEC SQL FETCH cursor_bajas_cel INTO :szRowid,:lhCodCliente,:lhNumAbonado,:szFecBaja;
          
          lRetrievRows = sqlca.sqlerrd[2] - lLastRows;
          lLastRows = sqlca.sqlerrd[2];

          for (i=0; i < lRetrievRows; i++) 
          {
               pstfa_ciclocli_nuevo = (rg_fa_ciclocli *) malloc (sizeof(rg_fa_ciclocli));

               if (pstfa_ciclocli_nuevo == NULL) 
               {
                   fprintf(stderr,"\tFalla en la asignacion de memoria en RG_FA_CICLOCLI BAJAS CEL\n");
                   exit(1);
               }

               strcpy(pstfa_ciclocli_nuevo->rowid , szRowid[i]);
               pstfa_ciclocli_nuevo->cod_cliente  = lhCodCliente[i];
               pstfa_ciclocli_nuevo->num_abonado  = lhNumAbonado[i];
               pstfa_ciclocli_nuevo->cod_producto = 1;
               pstfa_ciclocli_nuevo->num_proceso  = 0;
               pstfa_ciclocli_nuevo->ind_gravedad = 0;
               pstfa_ciclocli_nuevo->pos_empresa  = 0;
               strcpy(pstfa_ciclocli_nuevo->fec_baja , szFecBaja[i]);
               pstfa_ciclocli_nuevo->sigte = NULL;

               if (pstfa_ciclocli_primero==NULL)
               {
                   pstfa_ciclocli_primero = pstfa_ciclocli_nuevo;
                   pstfa_ciclocli_ultimo = pstfa_ciclocli_nuevo;
               }
               else 
               {
                   pstfa_ciclocli_ultimo->sigte = pstfa_ciclocli_nuevo;
                   pstfa_ciclocli_ultimo = pstfa_ciclocli_nuevo;
               }
               lCantidad++;
           }
    }

    EXEC SQL CLOSE cursor_bajas_cel;
    return(lCantidad - 1);
}

/********************************************************************************************/
int iBuscaBajas_Habocel ()
{
    rg_fa_ciclocli  *pstfa_ciclocli_nuevo;

    int         i;
    long        lLastRows    = 0;
    long        lFetchedRows = 10000;
    long        lRetrievRows = 10000;
    long        lCantidad       = 0;

    EXEC SQL BEGIN DECLARE SECTION;
         char szRowid[MAXFETCH][19];
         long lhCodCliente[MAXFETCH];
         long lhNumAbonado[MAXFETCH];
    EXEC SQL END DECLARE SECTION;

    fprintf(stderr,"\n\t iBuscaBajas_Habocel \n");
    vFechaHora();

    EXEC SQL DECLARE cursor_habocel CURSOR FOR
         SELECT A.ROWID, A.COD_CLIENTE, A.NUM_ABONADO
         FROM FA_CICLOCLI A, GA_HABOCEL B  
         WHERE A.COD_CICLO   = :fa_ciclfact->cod_ciclo
         AND A.NUM_PROCESO   = 0
         AND A.COD_PRODUCTO  = 1
         AND A.FEC_ALTA     <= :fa_ciclfact->fec_hasta  
         AND B.NUM_ABONADO   = A.NUM_ABONADO
         AND B.COD_SITUACION = 'REA'
         AND B.FEC_BAJACEN   < :fa_ciclfact->fec_desde
         ORDER BY A.COD_CLIENTE, A.NUM_ABONADO;

    EXEC SQL OPEN cursor_habocel;

    while(lFetchedRows == lRetrievRows)
    {
          EXEC SQL FETCH cursor_habocel INTO :szRowid,:lhCodCliente,:lhNumAbonado;

          lRetrievRows = sqlca.sqlerrd[2] - lLastRows;
          lLastRows = sqlca.sqlerrd[2];

          for (i=0; i < lRetrievRows; i++) 
          {
               pstfa_ciclocli_nuevo = (rg_fa_ciclocli *) malloc (sizeof(rg_fa_ciclocli));

               if (pstfa_ciclocli_nuevo == NULL) 
               {
                   fprintf(stderr,"\tFalla en la asignacion de memoria en RG_FA_CICLOCLI HABOCEL\n");
                   exit(1);
               }

               strcpy(pstfa_ciclocli_nuevo->rowid , szRowid[i]);
               pstfa_ciclocli_nuevo->cod_cliente  = lhCodCliente[i];
               pstfa_ciclocli_nuevo->num_abonado  = lhNumAbonado[i];
               pstfa_ciclocli_nuevo->cod_producto = 1;
               pstfa_ciclocli_nuevo->num_proceso  = 0;
               pstfa_ciclocli_nuevo->ind_gravedad = 0;
               pstfa_ciclocli_nuevo->pos_empresa  = 0;
               pstfa_ciclocli_nuevo->sigte = NULL;

               if (pstfa_ciclocli_primero==NULL)
               {
                   pstfa_ciclocli_primero = pstfa_ciclocli_nuevo;
                   pstfa_ciclocli_ultimo = pstfa_ciclocli_nuevo;
               }
               else 
               {
                   pstfa_ciclocli_ultimo->sigte = pstfa_ciclocli_nuevo;
                   pstfa_ciclocli_ultimo = pstfa_ciclocli_nuevo;
               }
               lCantidad++;
           }
    }
    
    EXEC SQL CLOSE cursor_habocel;
    return(lCantidad-1);
}
/********************************************************************************************/

int iBusca_Altas_FaCicloCli ()
{
    rg_fa_ciclocli  *pstfa_ciclocli_nuevo;

    int         i;
    long        lLastRows    = 0;
    long        lFetchedRows = 10000;
    long        lRetrievRows = 10000;
    long        lCantidad       = 0;

    EXEC SQL BEGIN DECLARE SECTION;
         char szRowid[MAXFETCH][19];
         long lhCodCliente[MAXFETCH];
         long lhNumAbonado[MAXFETCH];
         int  iCodProducto[MAXFETCH];
    EXEC SQL END DECLARE SECTION;

    fprintf(stderr,"\n\t iBusca_Altas_FaCicloCli \n");
    vFechaHora();

    EXEC SQL DECLARE cursor_altas CURSOR FOR
         SELECT /*+ ALL ROWS */
                ROWID, A.COD_CLIENTE, A.NUM_ABONADO, A.COD_PRODUCTO, A.NUM_PROCESO,0 ,0 
         FROM FA_CICLOCLI A  
         WHERE A.COD_CICLO = :fa_ciclfact->cod_ciclo
         AND A.NUM_PROCESO = 0
         AND A.FEC_ALTA    > :fa_ciclfact->fec_hasta
         AND   NOT EXISTS ( SELECT 1 FROM GA_EMPRESA B
                            WHERE B.COD_CICLO= :fa_ciclfact->cod_ciclo 
                            AND A.COD_CLIENTE=B.COD_CLIENTE)  
         ORDER BY A.COD_CLIENTE, A.NUM_ABONADO;


    EXEC SQL OPEN cursor_altas;

    while(lFetchedRows == lRetrievRows)
    {
          EXEC SQL FETCH cursor_altas INTO :szRowid,:lhCodCliente,:lhNumAbonado,:iCodProducto;

          lRetrievRows = sqlca.sqlerrd[2] - lLastRows;
          lLastRows = sqlca.sqlerrd[2];

          for (i=0; i < lRetrievRows; i++) 
          {
               pstfa_ciclocli_nuevo = (rg_fa_ciclocli *) malloc (sizeof(rg_fa_ciclocli));

               if (pstfa_ciclocli_nuevo == NULL) 
               {
                   fprintf(stderr,"\tFalla en la asignacion de memoria en RG_FA_CICLOCLI ALTAS\n");
                   exit(1);
               }

               strcpy(pstfa_ciclocli_nuevo->rowid , szRowid[i]);
               pstfa_ciclocli_nuevo->cod_cliente  = lhCodCliente[i];
               pstfa_ciclocli_nuevo->num_abonado  = lhNumAbonado[i];
               pstfa_ciclocli_nuevo->cod_producto = iCodProducto[i];
               pstfa_ciclocli_nuevo->num_proceso  = 0;
               pstfa_ciclocli_nuevo->ind_gravedad = 0;
               pstfa_ciclocli_nuevo->pos_empresa  = 0;
               pstfa_ciclocli_nuevo->sigte = NULL;

               if (pstfa_ciclocli_primero==NULL)
               {
                   pstfa_ciclocli_primero = pstfa_ciclocli_nuevo;
                   pstfa_ciclocli_ultimo = pstfa_ciclocli_nuevo;
               }
               else 
               {
                   pstfa_ciclocli_ultimo->sigte = pstfa_ciclocli_nuevo;
                   pstfa_ciclocli_ultimo = pstfa_ciclocli_nuevo;
               }
               lCantidad++;
           }
    }
    EXEC SQL CLOSE cursor_altas;
    return(lCantidad-1);
}

/***************************************************************************/
/* Funcion que carga en memoria (estructura fa_ciclocli) los clientes /    */
/* abonados que se facturarian. Los numeros de proceso validos son 0 y -98,*/
/* es decir, los activos y las bajas/traspasos.                            */
/***************************************************************************/
int	iBusca_FaCicloCli ()
{
    rg_fa_ciclocli  *pstfa_ciclocli_nuevo;
    int         i;
    long        lLastRows    = 0;
    long        lFetchedRows = 10000;
    long        lRetrievRows = 10000;
    long        lCantidad       = 0;

    EXEC SQL BEGIN DECLARE SECTION;
         char szRowid[MAXFETCH][19];
         long lhCodCliente[MAXFETCH];
         long lhNumAbonado[MAXFETCH];
         int  iCodProducto[MAXFETCH];
         long lhNUmProceso[MAXFETCH];
         int ihNumProc1, ihNumProc2, ihNumProc3;
    EXEC SQL END DECLARE SECTION;

    fprintf(stderr,"\n\t iBusca_FaCicloCli \n");
    vFechaHora();

    ihNumProc1 = 0;
    ihNumProc2 = ANOM98;
    ihNumProc3 = ANOM99;

    EXEC SQL DECLARE cursor_cli CURSOR FOR
         SELECT /*+ ALL_ROWS */
                ROWID, COD_CLIENTE, NUM_ABONADO, COD_PRODUCTO, NUM_PROCESO
                FROM FA_CICLOCLI a  
                WHERE COD_CICLO = :fa_ciclfact->cod_ciclo
                AND NUM_PROCESO IN (:ihNumProc1, :ihNumProc2, :ihNumProc3)
                AND FEC_ALTA <= :fa_ciclfact->fec_hasta
                AND NOT EXISTS ( SELECT 1 
         FROM GA_EMPRESA b 
         WHERE b.COD_CICLO = :fa_ciclfact->cod_ciclo 
         AND a.COD_CLIENTE = b.COD_CLIENTE)
         ORDER BY COD_CLIENTE, NUM_ABONADO;

    EXEC SQL OPEN cursor_cli;

    while(lFetchedRows == lRetrievRows)
    {
          EXEC SQL FETCH cursor_cli INTO :szRowid,:lhCodCliente,:lhNumAbonado,:iCodProducto,:lhNUmProceso;

          lRetrievRows = sqlca.sqlerrd[2] - lLastRows;
          lLastRows = sqlca.sqlerrd[2];

          for (i=0; i < lRetrievRows; i++) 
          {
               pstfa_ciclocli_nuevo = (rg_fa_ciclocli *) malloc (sizeof(rg_fa_ciclocli));

               if (pstfa_ciclocli_nuevo == NULL) 
               {
                   fprintf(stderr,"\tFalla en la asignacion de memoria en RG_FA_CICLOCLI\n");
                   exit(1);
               }

               strcpy(pstfa_ciclocli_nuevo->rowid , szRowid[i]);
               pstfa_ciclocli_nuevo->cod_cliente  = lhCodCliente[i];
               pstfa_ciclocli_nuevo->num_abonado  = lhNumAbonado[i];
               pstfa_ciclocli_nuevo->cod_producto = iCodProducto[i];
               pstfa_ciclocli_nuevo->num_proceso  = lhNUmProceso[i];
               pstfa_ciclocli_nuevo->ind_gravedad = 0;
               pstfa_ciclocli_nuevo->pos_empresa  = 0;
               pstfa_ciclocli_nuevo->sigte = NULL;

               if (pstfa_ciclocli_primero==NULL)
               {
                   pstfa_ciclocli_primero = pstfa_ciclocli_nuevo;
                   pstfa_ciclocli_ultimo = pstfa_ciclocli_nuevo;
               }
               else 
               {
                   pstfa_ciclocli_ultimo->sigte = pstfa_ciclocli_nuevo;
                   pstfa_ciclocli_ultimo = pstfa_ciclocli_nuevo;
               }
               lCantidad++;
           }
    }
    EXEC SQL CLOSE cursor_cli;
    return(lCantidad-1);
}

/********************************************************************************************/
int iCargaInfaccel ()
{
    rg_ga_infaccel  *pstga_infaccel_nuevo;
    int         i;
    long        lLastRows    = 0;
    long        lFetchedRows = 10000;
    long        lRetrievRows = 10000;
    long        lCantidad       = 0;
    
    EXEC SQL BEGIN DECLARE SECTION;
         long lhCodCliente[MAXFETCH];
         long lhNumAbonado[MAXFETCH];
         int  ihIndActuac[MAXFETCH];
         int  ihIndCuentaContrlada[MAXFETCH];
         int  ihIndCargopro[MAXFETCH];
    EXEC SQL END DECLARE SECTION;

    fprintf(stderr,"\n\t iCargaInfaccel \n");
    vFechaHora();

    EXEC SQL DECLARE infac_cursor CURSOR FOR
         SELECT COD_CLIENTE, NUM_ABONADO, IND_ACTUAC, IND_CUENCONTROLADA, IND_CARGOPRO
         FROM GA_INFACCEL
         WHERE COD_CICLFACT  = :cod_ciclfact
         ORDER BY COD_CLIENTE, NUM_ABONADO;
         
    EXEC SQL OPEN infac_cursor;

    while(lFetchedRows == lRetrievRows)
    {
          EXEC SQL FETCH infac_cursor INTO :lhCodCliente,:lhNumAbonado,:ihIndActuac,:ihIndCuentaContrlada,:ihIndCargopro;

          lRetrievRows = sqlca.sqlerrd[2] - lLastRows;
          lLastRows = sqlca.sqlerrd[2];

          for (i=0; i < lRetrievRows; i++) 
          {
               pstga_infaccel_nuevo = (rg_ga_infaccel *) malloc (sizeof(rg_ga_infaccel));

               if (pstga_infaccel_nuevo == NULL) 
               {
                   fprintf(stderr,"\tFalla en la asignacion de memoria en RG_GA_INFACCEL\n");
                   exit(1);
               }

               pstga_infaccel_nuevo->cod_cliente         = lhCodCliente[i];
               pstga_infaccel_nuevo->num_abonado         = lhNumAbonado[i];
               pstga_infaccel_nuevo->ind_actuac          = ihIndActuac[i];
               pstga_infaccel_nuevo->ind_cuencontrolada  = ihIndCuentaContrlada[i];
               pstga_infaccel_nuevo->ind_cargopro        = ihIndCargopro[i];
               pstga_infaccel_nuevo->sigte = NULL;

               if (pstga_infaccel_primero==NULL)
               {
                   pstga_infaccel_primero = pstga_infaccel_nuevo;
                   pstga_infaccel_ultimo = pstga_infaccel_nuevo;
               }
               else 
               {
                   pstga_infaccel_ultimo->sigte = pstga_infaccel_nuevo;
                   pstga_infaccel_ultimo = pstga_infaccel_nuevo;
               }
               lCantidad++;
          }
    }

    EXEC SQL CLOSE infac_cursor;
    return(lCantidad-1);
}

/********************************************************************************************/
int iCargaInfacbeep ()
{
    rg_ga_infacbeep  *pstga_infacbeep_nuevo;
    int         i;
    long        lLastRows    = 0;
    long        lFetchedRows = 10000;
    long        lRetrievRows = 10000;
    long        lCantidad       = 0;

    EXEC SQL BEGIN DECLARE SECTION;
         long  lhCodCliente[MAXFETCH];
         long  lhNumAbonado[MAXFETCH];
         int   ihIndActuac[MAXFETCH];
         int   ihIndCargopro[MAXFETCH];
         short shIndicador[MAXFETCH];
    EXEC SQL END DECLARE SECTION;

    fprintf(stderr,"\n\t iCargaInfaccel \n");
    vFechaHora();

    EXEC SQL DECLARE infac_cursor_beep CURSOR FOR
         SELECT COD_CLIENTE, NUM_ABONADO, IND_ACTUAC, IND_CARGOPRO
         FROM GA_INFACBEEP
         WHERE COD_CICLFACT  = :cod_ciclfact
         ORDER BY COD_CLIENTE, NUM_ABONADO;

    EXEC SQL OPEN infac_cursor_beep;
 
    while(lFetchedRows == lRetrievRows)
    {
          EXEC SQL FETCH infac_cursor_beep INTO:lhCodCliente,:lhNumAbonado,:ihIndActuac,:ihIndCargopro INDICATOR :shIndicador;

         lRetrievRows = sqlca.sqlerrd[2] - lLastRows;
         lLastRows = sqlca.sqlerrd[2];

         for (i=0; i < lRetrievRows; i++) 
         {
              pstga_infacbeep_nuevo = (rg_ga_infacbeep *) malloc (sizeof(rg_ga_infacbeep));

              if (pstga_infacbeep_nuevo == NULL) 
              {
                  fprintf(stderr,"\tFalla en la asignacion de memoria en RG_GA_INFACBEEP\n");
                  exit(1);
              }

              pstga_infacbeep_nuevo->cod_cliente         = lhCodCliente[i];
              pstga_infacbeep_nuevo->num_abonado         = lhNumAbonado[i];
              pstga_infacbeep_nuevo->ind_actuac          = ihIndActuac[i];
              pstga_infacbeep_nuevo->ind_cargopro        = ihIndCargopro[i];
              pstga_infacbeep_nuevo->indicador           = shIndicador[i];
              pstga_infacbeep_nuevo->sigte = NULL;

              if (pstga_infacbeep_primero==NULL)
              {
                  pstga_infacbeep_primero = pstga_infacbeep_nuevo;
                  pstga_infacbeep_ultimo = pstga_infacbeep_nuevo;
              }
              else 
              {
                  pstga_infacbeep_ultimo->sigte = pstga_infacbeep_nuevo;
                  pstga_infacbeep_ultimo = pstga_infacbeep_nuevo;
              }
              lCantidad++;
         }
    }
    
    EXEC SQL CLOSE infac_cursor_beep;
    return(lCantidad-1);
}

/********************************************************************************************/
void vBusca_Infacbeep (rg_fa_ciclocli *f)
{
    rg_ga_infacbeep *rgip;
    int Flag;
    int k=0;

    EXEC SQL BEGIN DECLARE SECTION;
         int  ihContador = 0;
         long lhCodCliente;
    EXEC SQL END DECLARE SECTION;

    lhCodCliente = f->cod_cliente;

    Flag = 0;

    if (pstga_infacbeep_posicion_aux == NULL)
        rgip = pstga_infacbeep_primero;
    else
        rgip = pstga_infacbeep_posicion_aux;

    for ( ;rgip != NULL && f->cod_cliente >= rgip->cod_cliente;rgip = rgip->sigte)
    {
          if ((f->cod_cliente == rgip->cod_cliente) && (f->num_abonado == rgip->num_abonado))
          { 
              Flag = 1;
              break;
          }
          k++;
    }

    if (Flag == 0) 
    { /* No se encontro registro en GA_INFACBEEP */
       if (f->num_proceso == RET_OK) 
       { /* No es baja */
          EXEC SQL
               SELECT COUNT(1)
               INTO :ihContador
               FROM GA_INFACBEEP
               WHERE COD_CLIENTE = :lhCodCliente
               AND  COD_CICLFACT = :cod_ciclfact;

          if(sqlca.sqlcode < 0)
             vSqlError();

          if(ihContador > 0) 
          { /* Se encontraron registros fuera del periodo. */
             anom42++;
             f->ret_infac = ANOM42;  
          }
          else 
          {/* Definitivamente no existe ningun registro. */
             anom43++;
             f->ret_infac = ANOM43;  
          }    
       }

       if (f->num_proceso == ANOM98) 
       { /* Es baja  o traspaso*/
           f->num_proceso = ANOM99;
           f->ret_infac = ANOM99;
       }
    }  
    else 
    { /* Se encontro al cliente/abonado en GA_INFACBEEP, para el periodo. */
       pstga_infacbeep_posicion_aux = rgip;
       if((f->num_proceso == ANOM98) && (rgip->ind_actuac != 2) && (rgip->ind_actuac != 3))
       {
          /* Esta activo, pero el ind_actuac no corresponde en Infaccel (Warning2) */
       }
       /* En cualquier caso, sea activo, baja o traspaso, se valida lo que sigue */
       /*------------------------------------------------------------------------*/
       if((rgip->indicador == -1) || (rgip->ind_cargopro == 0))
       {
          anom41++;
          f->ret_infac = ANOM41;
       }
       f->ret_infac = RET_OK;
    } 
}

/********************************************************************************************/
void vBusca_Infaccel (rg_fa_ciclocli *f)
{
    rg_ga_infaccel  *rgil;
    int Flag;
    int k=0;

    EXEC SQL BEGIN DECLARE SECTION;
         int ihContador = 0;
         long lhCodCliente;
         long lhNumAbonado;
         int ihContador_Abocel = 0;
    EXEC SQL END DECLARE SECTION;

    lhCodCliente = f->cod_cliente;
    lhNumAbonado = f->num_abonado;

    Flag = 0;

    if (pstga_infaccel_posicion_aux == NULL)
        rgil = pstga_infaccel_primero;
    else
        rgil = pstga_infaccel_posicion_aux;

    for( ;rgil != NULL && f->cod_cliente >= rgil->cod_cliente;rgil = rgil->sigte)
    {
         if ((f->cod_cliente == rgil->cod_cliente) && (f->num_abonado == rgil->num_abonado))
         { 
              Flag = 1;
              break;
         }
         k++;
   }

   if (Flag == 0) 
   { /* No se encontro registro en GA_INFACCEL */
       if (f->num_abonado == 0)
       {/* Si se trata del abonado 0, hay que validar si tiene otros abonados activos */
           EXEC SQL
                SELECT COUNT(1)
                INTO :ihContador
                FROM GA_INFACCEL
                WHERE COD_CLIENTE = :lhCodCliente
                AND   COD_CICLFACT = :cod_ciclfact
                AND   IND_ACTUAC NOT IN (2,3);

          if(sqlca.sqlcode < 0)
             vSqlError();

          if(ihContador > 0) /* El cliente tiene al menos 1 abonado activo.              */
             /* Por lo tanto, el abonado 0 deberia estar tambien activo. */ 
             f->ret_infac = RET_OK;  
            /* Se retorna como OK, pero el proceso de chequeo de  empresas lo delatara. */
          else 
          {/* No hay ningun abonado activo. Entonces, se trata de una baja. */
             f->num_proceso = ANOM99;
             f->ret_infac = ANOM99;
          }    
       }
       else 
       {/* No es el abonado 0 */
          if(f->num_proceso == RET_OK) 
          {/* No es baja */
             EXEC SQL   
                  SELECT COUNT(1) 
                  INTO :ihContador
                  FROM GA_INFACCEL
                  WHERE COD_CLIENTE = :lhCodCliente
                  AND NUM_ABONADO   = :lhNumAbonado;

             if(sqlca.sqlcode < 0)
                vSqlError();

             if(ihContador > 0) 
             {/* No existen registros para el periodo en analisis, pero si para otros. */
                ihContador_Abocel=0;
            
                EXEC SQL 
                     SELECT COUNT(1) 
                     INTO :ihContador_Abocel
                     FROM GA_ABOCEL
                     WHERE COD_CLIENTE = :lhCodCliente
                     AND NUM_ABONADO   = :lhNumAbonado
                     AND COD_SITUACION ='BAA' 
                     AND FEC_BAJACEN < SYSDATE-90;

                if (ihContador_Abocel >0)
                {
                    f->num_proceso = ANOM99;
                    f->ret_infac = ANOM99;
                }
                else
                {
                    anom13++;
                    f->ret_infac = ANOM13;
                }
             }
             else 
                {/* No existe ningun registro en GA_INFACCEL. */
                 ihContador_Abocel=0;
                 
                 EXEC SQL 
                      SELECT COUNT(1) 
                      INTO :ihContador_Abocel
                      FROM GA_ABOCEL
                      WHERE COD_CLIENTE = :lhCodCliente
                      AND NUM_ABONADO   = :lhNumAbonado
                      AND COD_SITUACION ='BAA' 
                      AND FEC_BAJACEN < SYSDATE-90;

                 if (ihContador_Abocel >0)
                 {
                     f->num_proceso = ANOM99;
                     f->ret_infac = ANOM99;
                 }
                 else
                 {
                     anom14++;
                     f->ret_infac = ANOM14;
                 }
                }
           }

           if(f->num_proceso == ANOM98) 
           {
             /* Es baja  o traspaso y ya no se ha replicado el registro en la ga_infaccel. */
             /* No se replico registro en ga_infaccel, por lo que se considera baja definitiva */
             f->num_proceso = ANOM99;
             f->ret_infac = ANOM99;
           }
       }
    }
    else
    {/* Se encontro al cliente/abonado antes de terminar el arreglo de ga_infaccel */
       pstga_infaccel_posicion_aux = rgil;
       if((f->num_proceso == ANOM98) && (rgil->ind_actuac != 2) && (rgil->ind_actuac != 3)) 
       {
          /* Es baja o traspaso, pero el ind_actuac no corresponde en Infaccel (Warning1) */
          /* Validar si el registro debe haber sido replicado o no.                       */
       }

       if((f->num_proceso == RET_OK) && ((rgil->ind_actuac == 2) || (rgil->ind_actuac == 3))) 
       {
          /* Esta activo, pero el ind_actuac no corresponde en Infaccel (Warning2) */
       }

       /* En cualquier caso, sea activo, baja o traspaso, se valida lo que sigue */
       /*------------------------------------------------------------------------*/
       if(rgil->ind_cuencontrolada == -1) 
       {/* Indicador de cuenta controlada en nulo. */
          anom11++;
          f->ret_infac = ANOM11;
       }
       
       if(rgil->ind_cargopro == -1) 
       {/* Indicador de cargo prorrateable en nulo. */
          anom12++;
          f->ret_infac = ANOM12;
       }

       f->ret_infac = RET_OK;
    }
}

/********************************************************************************************/
void vBusca_Intarcel(rg_fa_ciclocli *f)
{
    EXEC SQL BEGIN DECLARE SECTION;
    int  ihContador = 0;
    long lhCodCliente;
    long lhNumAbonado;
    EXEC SQL END DECLARE SECTION;


    int iCantCuotas = 0;

    lhCodCliente = f->cod_cliente;
    lhNumAbonado = f->num_abonado;
    
    /*               Se omitirá la validación para cualquier cliente/abonado cuyo traspaso no */
    /*               se menos a tres meses de lab fecha de comienzo del periodo               */
    
    
    EXEC SQL SELECT COUNT(1)
    INTO :ihContador
    FROM GA_TRASPABO
    WHERE NUM_ABONADOANT   = :lhNumAbonado
    AND COD_CLIENANT    = :lhCodCliente
    AND FEC_MODIFICA BETWEEN ADD_MONTHS(:fa_ciclfact->fec_desde,-3) AND :fa_ciclfact->fec_hasta;


    if(sqlca.sqlcode < 0)
        vSqlError();

    if(ihContador > 0){
        f->ret_infac = RET_OK; /* Cliente tiene traspaso se asume OK*/
      }
    else
    {
        EXEC SQL SELECT COUNT(1)
        INTO :ihContador
        FROM GA_INTARCEL
        WHERE COD_CLIENTE = :lhCodCliente
        AND NUM_ABONADO   = :lhNumAbonado
        AND FEC_HASTA    >= :fa_ciclfact->fec_desde
        AND COD_CICLO     = :fa_ciclfact->cod_ciclo;
        
        if(sqlca.sqlcode < 0)
            vSqlError();
        
        if(ihContador > 0){
            f->ret_infac = RET_OK;
          }
        /*else
        {
          CHEQUEO DE CUOTAS PENDIENTES DEL CLIENTE*/
          /*iCantCuotas = iCheckCuotas(f->cod_cliente); INC000000014051
          if (iCantCuotas == 0)
          {*/
          
          /*Inicio INC000000014051*/
          /* Se comenta la llamada a esta funcion ya que no debe realizar chequeo de cargos puesto que lo hace el abofact*/
          /* Se chequean cargos del cliente (retorno > 0 tiene cargos, = 0 no tiene cargos, < 0 error en la consulta)*/
          /*if (ifnCheckCargos(f->cod_cliente,cod_ciclfact) <= 0)               
          {
              EXEC SQL 
                   SELECT COUNT(1)
                   INTO :ihContador
                   FROM GA_INTARCEL
                   WHERE COD_CLIENTE = :lhCodCliente
                   AND NUM_ABONADO   = :lhNumAbonado
                   AND FEC_HASTA    >= :fa_ciclfact->fec_desde;
        
              if(sqlca.sqlcode < 0) 
                 vSqlError();
        
              if(ihContador > 0)
              {
                 anom15++;
                 f->ret_infac = ANOM15;
              }
              else
              {
                 anom16++;
                 f->ret_infac = ANOM16;
              }
          }
          else
          {
              f->ret_infac = RET_OK;
          }  Fin Chequea Cargos */
          
          /*Fin INC000000014051*/
              
          /*}*//*CHEQUEA CUOTAS INC000000014051*/          
          /*else
          {*/ /*CLIENTE AUN TIENE CUOTAS PENDIENTES*/          
          /*  f->ret_infac = RET_OK;*/
          /*}
          
        }*/
    }
}

/********************************************************************************************/
void vBusca_Intarbeep (rg_fa_ciclocli *f)
{
    EXEC SQL BEGIN DECLARE SECTION;
         int     ihContador = 0;
         long    lhCodCliente;
         long    lhNumAbonado;
    EXEC SQL END DECLARE SECTION;

    lhCodCliente = f->cod_cliente;
    lhNumAbonado = f->num_abonado;

    EXEC SQL 
         SELECT COUNT(1) 
         INTO :ihContador
         FROM GA_INTARBEEP
         WHERE COD_CLIENTE = :lhCodCliente
         AND NUM_ABONADO   = :lhNumAbonado
         AND FEC_HASTA    >= :fa_ciclfact->fec_desde
         AND COD_CICLO     = :fa_ciclfact->cod_ciclo;

    if(sqlca.sqlcode < 0)
       vSqlError();

    if(ihContador > 0) 
       f->ret_infac = RET_OK;
    else 
    {
       EXEC SQL 
       SELECT COUNT(1)   
       INTO :ihContador
       FROM GA_INTARBEEP
       WHERE COD_CLIENTE = :lhCodCliente
       AND NUM_ABONADO   = :lhNumAbonado
       AND FEC_HASTA    >= :fa_ciclfact->fec_desde;

       if(sqlca.sqlcode < 0)
          vSqlError();

       if(ihContador > 0) 
       {
          anom44++;
          f->ret_infac = ANOM44;
       }
       else 
       {
          anom45++;
          f->ret_infac = ANOM45;
       }
    }
}

/********************************************************************************************/
void vUpdate_FaCicloCli (char *rowid, int anom)
{
    EXEC SQL BEGIN DECLARE SECTION;
         int ihNumProc = 0;
         char szRowid[19];
    EXEC SQL END DECLARE SECTION;

    ihNumProc = anom;
    strcpy(szRowid,rowid);

    EXEC SQL 
         UPDATE FA_CICLOCLI
          SET NUM_PROCESO   = :ihNumProc
          WHERE ROWID       = :szRowid;
   
    if(sqlca.sqlcode < 0) 
    { 
       vSqlError();
    }
}

/********************************************************************************************/
void vUpdate_Resto (rg_fa_ciclocli *f)
{
    rg_fa_ciclocli *rfc=NULL;
    int Flag = 0;

    if (pstfa_ciclocli_posicion_aux == NULL)
        rfc = pstfa_ciclocli_primero;
    else
        rfc = pstfa_ciclocli_posicion_aux;

    for( ;rfc != NULL && Flag == 0 && f->cod_cliente >= rfc->cod_cliente;rfc = rfc->sigte)
    {
         if (f->cod_cliente == rfc->cod_cliente)
         {
             while((f->cod_cliente == rfc->cod_cliente) && (rfc != NULL))
             {
                    if(rfc->ret_infac == 0)
                    {
                       rfc->ret_infac = RESTO;
                       vUpdate_FaCicloCli(rfc->rowid,rfc->ret_infac);
                       anom77++;
                    }
                    if (rfc->sigte != NULL)
                        rfc = rfc->sigte;
                    else
                        break;
             }
             pstfa_ciclocli_posicion_aux = rfc;
             Flag = 1;
         }
    }
    free(rfc);
}

/* ****************************************************************************** */
/* * Funcion checkFactActual                                                    * */
/* * Verifica si debe o no considerar un cliente para este ciclo de facturacion * */
/* ****************************************************************************** */
static BOOL checkFactActual(long lCodCliente, long lCodCiclFact, BOOL *bClieconFact)
{
    EXEC SQL BEGIN DECLARE SECTION;
         int  ihcont= 0;
    EXEC SQL END DECLARE SECTION;      

    EXEC SQL   
         SELECT  count(1) 
         INTO    :ihcont
         FROM FA_CICLOCLI A
         WHERE COD_CLIENTE= :lCodCliente
         AND EXISTS ( SELECT  1
                      FROM    CO_REG_DEUDACLI B
                      WHERE   A.COD_CLIENTE  = B.COD_CLIENTE
                      AND     B.COD_CICLFACT = :lCodCiclFact);

    if(SQLCODE != SQLOK)
    {
       fprintf(stderr, "\n\t** Error en Checkeo de SELECT FA_CICLOCLI ** "
                       "\n\t\t\t=>  Cliente    [%ld] "
                       "\n\t\t\t=>  Errror     [%d] [%s]"
                     , lCodCliente,SQLCODE,SQLERRM);
       return (FALSE);
    }

    if (ihcont > 0)
    {
        *bClieconFact = TRUE;
    }
    else
    {
        *bClieconFact = FALSE;
    }

    return (TRUE);
}

/********************************************************************************************/
int iClientes_Marcados ()
{
    EXEC SQL BEGIN DECLARE SECTION;
         int ihContador = 0;
    EXEC SQL END DECLARE SECTION;
    
    EXEC SQL 
         SELECT COUNT(DISTINCT COD_CLIENTE)
         INTO :ihContador
         FROM FA_CICLOCLI
         WHERE COD_CICLO = :fa_ciclfact->cod_ciclo
         AND NUM_PROCESO < 0;

    if(sqlca.sqlcode < 0)
    {
       vSqlError();
    }

    return(ihContador);
}

/********************************************************************************************/
int  Fecha_Bajas (char *szhFecBajas)
{
    EXEC SQL BEGIN DECLARE SECTION;
         char szhFecBajas_New [15]; EXEC SQL VAR szhFecBajas_New  IS STRING(15);	
    EXEC SQL END DECLARE SECTION;
  
    szhFecBajas[0]=0;

    EXEC SQL 
         SELECT  TO_CHAR(FEC_HASTALLAM - 90,'YYYYMMDDHH24MISS')
         INTO :szhFecBajas_New
         FROM FA_CICLFACT
         WHERE COD_CICLFACT = :cod_ciclfact;

    if(sqlca.sqlcode < 0)
    {
       vSqlError();
    }
    
    strcpy (szhFecBajas,szhFecBajas_New);
    return(0);
}

/*************************************************************/
/* Valida si el cliente abonado tiene cargos en la GE_CARGOS */
/*int ifnCheckCargos (long lCodCliente, long lCodCiclFact)
{
    EXEC SQL BEGIN DECLARE SECTION;
         long lhCodCliente;
         long lhCodCiclFact;
         int  iCargos = 0;
    EXEC SQL END DECLARE SECTION;

    lhCodCliente  = lCodCliente;
    lhCodCiclFact = lCodCiclFact;	

    EXEC SQL
         SELECT COUNT(1) 
         INTO   :iCargos
         FROM GE_CARGOS GC
         WHERE  GC.NUM_FACTURA     = 0
         AND  GC.NUM_TRANSACCION = 0
         AND  GC.IMP_CARGO      != 0
         AND  GC.COD_CLIENTE     = :lhCodCliente
         AND  GC.COD_CICLFACT    = :lhCodCiclFact
         AND  EXISTS (SELECT 1 FROM FA_CONCEPTOS_FACTURACION_VW FCF
                      WHERE FCF.COD_CONCEPTO = GC.COD_CONCEPTO);

    if(SQLCODE != SQLOK && SQLCODE != SQLNOTFOUND)
    {
        fprintf(stderr,"\n\t** Error en Checkeo de Cargos en GE_CARGOS ** "
                                    "\n\t\t\t=>  Cliente    [%ld] "
                                    "\n\t\t\t=>  Errror     [%d] [%s]"
                                    ,lCodCliente,SQLCODE,SQLERRM);
        fprintf(stderr, "\n\t** Error en Checkeo de Cargos en GE_CARGOS ** "
                                    "\n\t\t\t=>  Cliente    [%ld] "
                                    "\n\t\t\t=>  Errror     [%d] [%s]"
                                    ,lCodCliente,SQLCODE,SQLERRM);
        return (-1);
    }
    
    return (iCargos);
}*//******************************* fin ifnCheckCargos *******************************/

/*************************************************************/
/* Valida si el cliente abonado tiene cargos en la GE_CARGOS */
int ifnCheckCargos (long lCodCliente, long lCodCiclFact)
{
    EXEC SQL BEGIN DECLARE SECTION;
         long lhCodCliente;
         long lhCodCiclFact;
         int  ihCargos = 0;
    EXEC SQL END DECLARE SECTION;

    static char szhCadenaSQL[2048];
    memset(szhCadenaSQL,0,sizeof(szhCadenaSQL));
    
    lhCodCliente  = lCodCliente;
    lhCodCiclFact = lCodCiclFact;
    
    fprintf(stderr, "GE_CARGOS: Cliente [%ld] Ciclo [%ld] \n", lhCodCliente, lhCodCiclFact);
                  
    sprintf(szhCadenaSQL, "SELECT COUNT(1) \n"
                         "FROM   GE_CARGOS \n"
                         "WHERE  COD_CONCEPTO IN (%s) \n"
                         "AND    NUM_FACTURA      = 0 \n"
                         "AND    NUM_TRANSACCION  = 0 \n"
                         "AND    IMP_CARGO        != 0 \n"
                         "AND    COD_CICLFACT     = :v1 \n"
                         "AND    COD_CLIENTE      = :v2 \n"
                       , szValParametro);  
                       
    fprintf(stderr, "CadenaSQL  para Select en Tabla GE_CARGOS %s \n", szhCadenaSQL);
    
    EXEC SQL PREPARE sql_stmt FROM :szhCadenaSQL;
    if (SQLCODE != SQLOK)
    {
        fprintf(stderr, "Error en PREPARE GE_CARGOS, Error Oracle  %s \n", SQLERRM);
        return (FALSE);
    }                                                                 
        
    EXEC SQL DECLARE c_RegistroCargos CURSOR FOR sql_stmt;
    if (SQLCODE != SQLOK)
    {
        fprintf(stderr, "Error en DECLARE GE_CARGOS, Error Oracle  %s \n", SQLERRM);
        return (FALSE);
    }    
    
    EXEC SQL OPEN c_RegistroCargos USING :lhCodCiclFact, :lhCodCliente;
    if (SQLCODE != SQLOK)
    {
        fprintf(stderr, "Error en OPEN GE_CARGOS, Error Oracle  %s \n", SQLERRM);
        return (FALSE);
    }  
    
    if (SQLCODE != SQLOK && SQLCODE != SQLNOTFOUND )
    {
        fprintf(stderr, "Error en SELECT GE_CARGOS, Error Oracle  %s \n", SQLERRM);
        return (FALSE);
    }  
    
    if(SQLCODE == SQLNOTFOUND)
    {
       ihCargos = 0;
    }                              
    
    fprintf(stderr, "Cargos Cliente: [%d] \n", ihCargos);       
    
    return (ihCargos);
}/******************************* fin ifnCheckCargos *******************************/

/* ************************************************************************** */
/* ifnGetParametro : Obtiene el valor del parametro indicado de FAD_PARAMETRO */
/* ************************************************************************** */
int ifnGetParametro (int iCodParametro, char *szTipParametro, char *szValParametro )
{
    EXEC SQL BEGIN DECLARE SECTION;
        int     ihCodParametro      ;
        long    lhValNumerico       ;
        char    szhTipParametro [33]; EXEC SQL VAR szhTipParametro  IS STRING(33);
        char    szhValCaracter [513]; EXEC SQL VAR szhValCaracter   IS STRING(513);
        char    szhValFecha     [20]; EXEC SQL VAR szhValFecha      IS STRING(20);
        short   s_lhValNumerico     ;
        short   s_szhValCaracter    ;
        short   s_szhValFecha       ;
    EXEC SQL END DECLARE SECTION;
    
    fprintf(stderr, "Recuperar parametro, desde FAD_PARAMETROS COD_PARAMETRO = %d.\n", iCodParametro);

    ihCodParametro= iCodParametro;

    EXEC SQL
        SELECT TIP_PARAMETRO, VAL_NUMERICO, VAL_CARACTER, TO_CHAR(VAL_FECHA,'YYYYMMDDHH24MISS')
          INTO :szhTipParametro   ,
               :lhValNumerico  :s_lhValNumerico,
               :szhValCaracter :s_szhValCaracter,
               :szhValFecha    :s_szhValFecha
          FROM FAD_PARAMETROS
         WHERE COD_MODULO='FA'
           AND COD_PARAMETRO=:ihCodParametro;

    if(sqlca.sqlcode == SQLOK)
    {
        /*fprintf(stderr, "SQLOK FAD_PARAMETROS \n");*/
        
        if (strcmp (szhTipParametro ,"VARCHAR2") == 0)
        {
            if (s_szhValCaracter== ORA_NULL)    sprintf(szValParametro,"\0" );
            else                                sprintf(szValParametro,"%s\0" ,szhValCaracter);            	
        }
        else if (strcmp (szhTipParametro,"NUMBER") ==0)
        {
            if (s_lhValNumerico == ORA_NULL)    sprintf(szValParametro,"\0" );
            else                                sprintf(szValParametro,"%ld\0" ,lhValNumerico);
        }
        else if (strcmp (szhTipParametro,"DATE") == 0)
        {
            if (s_szhValFecha   == ORA_NULL)    sprintf(szValParametro,"\0" );
            else                                sprintf(szValParametro,"%s\0" ,szhValFecha);
        }
    }
    else
    {
        if (sqlca.sqlcode != SQLNOTFOUND)
            fprintf(stderr, "Error al recuperar parametro, desde FAD_PARAMETROS.\n");
    }
    return(sqlca.sqlcode);
}

/*******************************************************************************/
int main (int argc, char *argv[])
{
    /*---------------------------------------------------------------------------*/
    /* Variables para manejo de argumentos externos (getopt).                    */
    /*---------------------------------------------------------------------------*/
    extern char *optarg;
    extern int optind, optopt, opterr;
    int c=0, u_flag=FALSE, c_flag=FALSE;
    char opstring[] = ":u:c:";
    char *szUserid_Aux;
    char userid[70];
    rg_fa_ciclocli *rfci;
    int iCantCuotas = 0;
    char szFecBajas_New[15];
    BOOL bClieconFact;

    /*---------------------------------------------------------------------------*/
    /* Descriptores de archivo.                                                  */
    /*---------------------------------------------------------------------------*/
    FILE *fp_anom;

    /*---------------------------------------------------------------------------*/
    /* Variables de caracter general: Contadores, flags, etc..                   */
    /*---------------------------------------------------------------------------*/
    int cont=0, cont_infac=0, cont_bajas_cel=0, cont_bajas_beep=0, cm=0;
    int cont_infac_beep=0, cont_altas=0, cont_habobeep=0, cont_habocel=0;

    /*---------------------------------------------------------------------------*/
    /* Header.                                                                   */
    /*---------------------------------------------------------------------------*/
    vFechaHora();
    fprintf(stderr, "PROGRAMA DE DETECCION DE ANOMALIAS EN TABLAS DE INTERFAZ\n");
    fprintf (stderr,"\nExe->Check_Interfaz Version [%s] " __DATE__ " " __TIME__ " TMC \n\n",VERSION);
    fprintf(stderr, "\nNumero de proceso   : %d\n", getpid());

    /*---------------------------------------------------------------------------*/
    /* Manejo de argumentos ingresados como parametros externos.                 */
    /*---------------------------------------------------------------------------*/
    while ((c=getopt(argc, argv, opstring)) != EOF)
    {
         switch(c)
         {
                case 'u':
                         if(u_flag==FALSE)
                         {
                            if(optarg[0]=='-')
                            {
                               fprintf(stderr, "\nOpcion -%c tiene argumento invalido. Se cancela.\n", optopt);
                               fprintf(stderr, "USO ES: %s -c<cod_ciclfact> -u<username/password>\n\n", argv[0]);
                               exit(4);
                            }
                            strcpy(userid, optarg);
                            if((szUserid_Aux=(char *)strstr(userid,"/")) == (char *)NULL)
                            {
                                fprintf(stderr, "\nUsuario Oracle no es valido\n");
                                fprintf(stderr, "USO ES: %s -c<cod_ciclfact> -u<username/password>\n\n", argv[0]);
                                exit(4);
                            }
                            else
                            {
                                strncpy(username,userid,szUserid_Aux-userid);
                                strcpy (passwd,szUserid_Aux+1);
                            }
                         }
                         else
                         {
                            fprintf(stderr, "\nOpcion -%c duplicada. Se cancela.\n", optopt);
                            exit(4);
                         }
                         u_flag=TRUE;
                         break;

                case 'c':
                         if(c_flag==FALSE)
                         {
                            if(optarg[0]=='-')
                            {
                               fprintf(stderr, "\nOpcion -%c tiene argumento invalido. Se cancela.\n", optopt);
                               fprintf(stderr, "USO ES: %s -c<cod_ciclfact> -u<username/password>\n\n", argv[0]);
                               exit(4);
                            }
                            cod_ciclfact=atoi(optarg);
                         }
                         else
                         {
                            fprintf(stderr, "\nOpcion -%c duplicada. Se cancela.\n", optopt);
                            exit(4);
                         }
                         c_flag=TRUE;
                         break;

                case ':':
                         fprintf(stderr, "\nOpcion -%c requiere argumento\n", optopt);
                         fprintf(stderr, "USO ES: %s -c<cod_ciclfact> -u<username/password>\n\n", argv[0]);
                         exit(4);

                case '?':
                         fprintf(stderr, "\nOpcion -%c no reconocida\n", optopt);
                         fprintf(stderr, "USO ES: %s -c<cod_ciclfact> -u<username/password>\n\n", argv[0]);
                         exit(4);
         }
    }

    if(c_flag == FALSE)
    {
       fprintf(stderr, "\nSe requiere argumento -c<cod_ciclfact>\n");
       fprintf(stderr, "USO ES: %s -c<cod_ciclfact> -u<username/password>\n\n", argv[0]);
       exit(4);
    }

    /*---------------------------------------------------------------------------*/
    /* Configuracion del ambiente de ejecucion.                                  */
    /*---------------------------------------------------------------------------*/
    vFechaHora();
    fprintf(stderr, "Configurando ambiente \n");
    vConfig_Ambiente();

    /*---------------------------------------------------------------------------*/
    /* Inicializacion de variables.                                              */
    /*---------------------------------------------------------------------------*/
    fprintf(stderr, "vFechaHora() ...\n");
    vFechaHora();

    fprintf(stderr, "Inicializando variables ...\n");
    vInit_Variables();

    /*---------------------------------------------------------------------------*/
    /* Conexion a la base de datos Oracle.                                       */
    /*---------------------------------------------------------------------------*/

    if(fnOraConnect(username, passwd) == FALSE)
    {
       fprintf(stderr, "Usuario/Password Oracle no son validos. Se cancela.\n");
       exit(5);
    }
    else
    {
       vFechaHora();
       fprintf(stderr, "Conexion con la base de datos ha sido exitosa.\n");
       fprintf(stderr, "Username: %s\nPassword: ********\n", username);
    }

    /*---------------------------------------------------------------------------*/
    /* Alteracion de formato de fechas en sesion Oracle.                         */
    /*---------------------------------------------------------------------------*/
    EXEC SQL ALTER SESSION SET NLS_DATE_FORMAT = 'YYYYMMDDHH24MISS';
    
    /****************************************************/
    /* RECUPERACION DE PARAMETROS CONCEPTOS DE ARRIENDO */
    /****************************************************/    
 
    if (ifnGetParametro (2014, szTipParametro, szValParametro))
    {
        fprintf(stderr, "Error en obtencion de Conceptos Cuota Arriendo (Cod. 2014)\n");
        return (FALSE);
    }
    
    fprintf(stderr, "Conceptos Cuota de Arriendo : %s\n", szValParametro);
                              
    /*---------------------------------------------------------------------------*/
    /* Carga de estructura fa_ciclfact, que representa informacion del periodo,  */
    /* en terminos de fechas de vigencia y codigo de ciclo.                      */
    /*---------------------------------------------------------------------------*/
    vFechaHora();
    fprintf(stderr, "Buscando informacion en tabla FA_CICLFACT ...\n");
    vBusca_FaCiclFact();
    fprintf(stderr, "Ciclo      : %d\n", fa_ciclfact->cod_ciclo);
    fprintf(stderr, "Periodo    : %d\n", cod_ciclfact);
    fprintf(stderr, "Fecha Desde: %s\n", fa_ciclfact->fec_desde);
    fprintf(stderr, "Fecha Hasta: %s\n", fa_ciclfact->fec_hasta);

    Fecha_Bajas(szFecBajas_New);
  
    fprintf(stderr, "szFecBajas_New: %s\n", szFecBajas_New);

    vInit_Variables();

    vFechaHora();
    fprintf(stderr, "Buscando abonados celulares de baja en GA_HABOCEL (ventas rechazadas) ...\n");
    cont_habocel = iBuscaBajas_Habocel();

    vFechaHora();
    fprintf(stderr, "Marcando en FA_CICLOCLI los abonados celulares de baja en GA_HABOCEL ...\n");
    fp_anom=Abre_Arch(file_anom, "a");
    rfci = NULL;
    
    /*for(rfci = pstfa_ciclocli_primero;rfci != NULL;rfci = rfci->sigte) 
    {
        iCantCuotas = iCheckCuotas(rfci->cod_cliente);
        if (iCantCuotas == 0)
        { INC000000014051 */
        
        /*Inicio INC000000014051*/
        /* Se comenta la llamada a esta funcion ya que no debe realizar chequeo de cargos puesto que lo hace el abofact*/
        /* Evalua si el cliente tiene cargos en la GE_CARGOS */
        /*if(ifnCheckCargos(rfci->cod_cliente,cod_ciclfact) <= 0)
        {
           fprintf(fp_anom, "%.6d  %.6d  %d\n", rfci->cod_cliente, rfci->num_abonado, ANOM99);
           vUpdate_FaCicloCli(rfci->rowid,ANOM99);
           EXEC SQL COMMIT;
        } */
        /*Fin INC000000014051*/   
        
        /*}*//*Cliente con Cuotas Pendientes no se Marcan con Anomalias INC000000014051*/        
        /*else
        {
           if (iCantCuotas < 0)
               fprintf(stderr, "Error al obtener Cuotas de Cliente [%ld] en Habocel..\n",rfci->cod_cliente);
        }
    }*/
    
    fclose(fp_anom);
    vInit_Variables();

/*---------------------------------------------------------------------------*/
/* Busqueda y marcacion de abonados dados de baja. (cod_situacion = 'BAA' o  */
/* 'BAP' en tablas GA_ABOCEL y GA_ABOBEEP.)                                  */
/* Se marcan transitoriamente con anomalia ANOM98 = -98.                     */
/*---------------------------------------------------------------------------*/
    vFechaHora();
    fprintf(stderr, "Buscando abonados beeper dados de baja (GA_ABOBEEP) ...\n");
    cont_bajas_beep=iBuscaBajas_Beep();

    vFechaHora();
    fprintf(stderr, "Marcando en FA_CICLOCLI los abonados beeper dados de baja ...\n");
    fp_anom=Abre_Arch(file_anom, "a");
    rfci = NULL;
    
    for(rfci = pstfa_ciclocli_primero;rfci != NULL;rfci = rfci->sigte) 
    {
        if(strcmp(rfci->fec_baja, szFecBajas_New) > 0)
        {/* Nuevas bajas. */
           fprintf(fp_anom, "%.6d  %.6d  %d  [%s]\n", rfci->cod_cliente, rfci->num_abonado, ANOM98, rfci->fec_baja);
           vUpdate_FaCicloCli(rfci->rowid,ANOM98);
           EXEC SQL COMMIT;
        }
        /*else 
        { Antiguas bajas */
            
            /*Inicio INC000000014051*/
            /* Se comenta la llamada a esta funcion ya que no debe realizar chequeo de cargos puesto que lo hace el abofact*/
            /* Evalua si el cliente tiene cargos en la CO_CARTERA, si tiene no se marca como baja*/
            /*if(ifnCheckCargos(rfci->cod_cliente,rfci->num_abonado) <= 0)
            {
               fprintf(fp_anom, "%.6d  %.6d  %d\n", rfci->cod_cliente, rfci->num_abonado, ANOM99);
               vUpdate_FaCicloCli(rfci->rowid,ANOM99);
               EXEC SQL COMMIT;
            }*/
            /*Fin INC000000014051*/
        /*}*/
    }

    fclose(fp_anom);
    vInit_Variables();

    vFechaHora();
    fprintf(stderr, "Buscando abonados celulares dados de baja (GA_ABOCEL) ...\n");
    cont_bajas_cel=iBuscaBajas_Cel();

    vFechaHora();
    fprintf(stderr, "Marcando en FA_CICLOCLI los abonados celulares dados de baja ...\n");
    fp_anom = Abre_Arch(file_anom, "a");

    for(rfci = pstfa_ciclocli_primero;rfci != NULL;rfci = rfci->sigte) 
    {
        /*iCantCuotas = iCheckCuotas(rfci->cod_cliente);
        if (iCantCuotas == 0)
        { INC000000014051 */
        
        if(strcmp(rfci->fec_baja, szFecBajas_New) > 0)
        { 
           /*Nuevas bajas. */
           fprintf(fp_anom, "%.6d  %.6d  %d  [%s]\n", rfci->cod_cliente, rfci->num_abonado, ANOM98, rfci->fec_baja);
           vUpdate_FaCicloCli(rfci->rowid,ANOM98);
           EXEC SQL COMMIT;
        }
        /*else 
        {*/
        	  
        	  /*Inicio INC000000014051*/
        	  /* Se comenta la llamada a esta funcion ya que no debe realizar chequeo de cargos puesto que lo hace el abofact*/
        	  /* Evalua si el Cliente tiene cargos en la GE_CARGOS */
           /*if(ifnCheckCargos(rfci->cod_cliente, cod_ciclfact) <= 0)
           {
              fprintf(fp_anom, "%.6d  %.6d  %d\n", rfci->cod_cliente, rfci->num_abonado, ANOM99);
              vUpdate_FaCicloCli(rfci->rowid,ANOM99);
              EXEC SQL COMMIT;
           }*/
           /*Fin INC000000014051*/
        /*}
            
        }
        else
        {
            if (iCantCuotas < 0)
                fprintf(stderr, "Error al obtener Cuotas de Cliente [%ld] en Habocel..\n",rfci->cod_cliente);
        }*/
    }
    fclose(fp_anom);
    vInit_Variables();

    /*---------------------------------------------------------------------------*/
    /* Carga de tablas GA_INFACCEL y GA_INFACBEEP, para el periodo en analisis,  */
    /* en la memoria.                                                            */
    /*---------------------------------------------------------------------------*/
    vFechaHora();
    fprintf(stderr, "Llevando a memoria informacion de clientes/abonados en tablas GA_INFACCEL y GA_INFACBEEP ...\n");
    cont_infac=iCargaInfaccel();
    cont_infac_beep=iCargaInfacbeep();

    /*---------------------------------------------------------------------------*/
    /* Busqueda y marcacion de abonados de alta mas alla del cierre del periodo. */
    /*---------------------------------------------------------------------------*/
    vFechaHora();
    fprintf(stderr, "Buscando clientes/abonados dados de alta mas alla del cierre del periodo ...\n");
    cont_altas=iBusca_Altas_FaCicloCli();

    vFechaHora();
    fprintf(stderr, "Marcando en FA_CICLOCLI los abonados dados de alta ...\n");
    for(rfci = pstfa_ciclocli_primero;rfci != NULL;rfci = rfci->sigte) 
    {
        vUpdate_FaCicloCli(rfci->rowid,ANOM95);
        EXEC SQL COMMIT;
    }
    vInit_Variables();

    /*---------------------------------------------------------------------------*/
    /* Carga en memoria de clientes/abonados que serian facturados en el periodo.*/
    /* Dentro de este universo se consideran las bajas y traspasos (ANOM98).     */
    /*---------------------------------------------------------------------------*/
    vFechaHora();
    fprintf(stderr, "Buscando informacion de clientes/abonados a facturar (FA_CICLOCLI) ...\n");
    cont=iBusca_FaCicloCli();

    /*---------------------------------------------------------------------------*/
    /* Busqueda de anomalias en tablas de interfaz.                              */
    /*---------------------------------------------------------------------------*/
    vFechaHora();
    fprintf(stderr, "Buscando anomalias en tablas de interfaz ...\n");
    fp_anom = Abre_Arch(file_anom, "a");

    for(rfci = pstfa_ciclocli_primero; rfci != NULL ; rfci = rfci->sigte) 
    {
        if(rfci->num_proceso != ANOM99)
        {
           if(rfci->cod_producto == PROD_CELULAR)
           {
              vBusca_Infaccel(rfci);
              if(rfci->ret_infac < 0)
                 fprintf(fp_anom, "%.6d  %.6d  %d\n", rfci->cod_cliente, rfci->num_abonado, rfci->ret_infac);
              else 
              {
                 if((rfci->num_proceso != ANOM98) && (rfci->num_abonado != 0)) 
                 {/* Si el abonado no esta de baja ni traspasado. */
                     vBusca_Intarcel(rfci);
                     if(rfci->ret_infac < 0)
                        fprintf(fp_anom, "%.6d  %.6d  %d\n", rfci->cod_cliente, rfci->num_abonado, rfci->ret_infac);
                 }
              }
           }
           else 
           {   /* Producto beeper. */
               vBusca_Infacbeep(rfci);
               if(rfci->ret_infac < 0)
                  fprintf(fp_anom, "%.6d  %.6d  %d\n", rfci->cod_cliente, rfci->num_abonado, rfci->ret_infac);
               else 
               {
                  if(rfci->num_proceso != ANOM98) 
                  {/* Si el abonado no esta de baja ni traspasado. */
                     vBusca_Intarbeep(rfci);
                     if(rfci->ret_infac < 0)
                        fprintf(fp_anom, "%.6d  %.6d  %d\n", rfci->cod_cliente, rfci->num_abonado, rfci->ret_infac);
                  }
               }
           }
        } /* end if anom99*/
    } /* Fin for */
    fclose(fp_anom);

    vFechaHora();
    fprintf(stderr, "Marcando anomalias en tabla FA_CICLOCLI ...\n");
    for(rfci = pstfa_ciclocli_primero; rfci != NULL ; rfci = rfci->sigte) 
    {
        if((rfci->ret_infac < 0) && (rfci->num_proceso != ANOM98) && (rfci->num_proceso != ANOM99))
        {
            vUpdate_FaCicloCli(rfci->rowid,rfci->ret_infac);
            if(rfci->ret_infac != ANOM99)
            {	/* Si no es baja definitiva */
               vUpdate_Resto(rfci);
            }
        }
        if(rfci->num_proceso == ANOM98) 
        {
           rfci->num_proceso = RET_OK;
           vUpdate_FaCicloCli(rfci->rowid, RET_OK);
        }

        /* comentaremos la validación del -99 debido a que con los cambios en el abofact, ya no será necesario validarlos */ /*FT_XXXXX*/
        /*if(rfci->num_proceso == ANOM99)
        {
           checkFactActual(rfci->cod_cliente, cod_ciclfact, &bClieconFact);
           if( bClieconFact == TRUE )
           {
               rfci->num_proceso = RET_OK;
               vUpdate_FaCicloCli(rfci->rowid, RET_OK);
           }
        }*/ /*FT_XXXXX*/
    }

    vFechaHora();
    fprintf(stderr, "Contabilizando los clientes marcados en tabla FA_CICLOCLI ...\n");
    cm = iClientes_Marcados();

    fprintf(stderr, "\nEstadistica                    del                           proceso:\n");
    fprintf(stderr, "========================\n");
    fprintf(stderr, "Cantidad de abonados a facturar        : %.6d\n", cont+1);
    fprintf(stderr, "Cantidad de bajas en GA_HABOBEEP       : %.6d\n", cont_habobeep+1);
    fprintf(stderr, "Cantidad de bajas en GA_HABOCEL        : %.6d\n", cont_habocel+1);
    fprintf(stderr, "Cantidad de abonados celulares de baja : %.6d\n", cont_bajas_cel+1);
    fprintf(stderr, "Cantidad de abonados beeper de baja    : %.6d\n", cont_bajas_beep+1);
    fprintf(stderr, "Cantidad de abonados dados de alta     : %.6d\n", cont_altas+1);
    fprintf(stderr, "Cantidad de abonados en GA_INFACCEL    : %.6d\n", cont_infac+1);
    fprintf(stderr, "Cantidad de abonados en GA_INFACBEEP   : %.6d\n", cont_infac_beep+1);
    fprintf(stderr, "Cantidad de abonados con anomalia 10   : %.6d\n", anom10);
    fprintf(stderr, "Cantidad de abonados con anomalia 11   : %.6d\n", anom11);
    fprintf(stderr, "Cantidad de abonados con anomalia 12   : %.6d\n", anom12);
    fprintf(stderr, "Cantidad de abonados con anomalia 13   : %.6d\n", anom13);
    fprintf(stderr, "Cantidad de abonados con anomalia 14   : %.6d\n", anom14);
    fprintf(stderr, "Cantidad de abonados con anomalia 15   : %.6d\n", anom15);
    fprintf(stderr, "Cantidad de abonados con anomalia 16   : %.6d\n", anom16);
    fprintf(stderr, "Cantidad de abonados con anomalia 40   : %.6d\n", anom40);
    fprintf(stderr, "Cantidad de abonados con anomalia 41   : %.6d\n", anom41);
    fprintf(stderr, "Cantidad de abonados con anomalia 42   : %.6d\n", anom42);
    fprintf(stderr, "Cantidad de abonados con anomalia 43   : %.6d\n", anom43);
    fprintf(stderr, "Cantidad de abonados con anomalia 44   : %.6d\n", anom44);
    fprintf(stderr, "Cantidad de abonados con anomalia 45   : %.6d\n", anom45);
    fprintf(stderr, "Cantidad de abonados marcados con 77   : %.6d\n", anom77);
    fprintf(stderr, "Cantidad de clientes anomalos marcados : %.6d\n", cm);

    vFechaHora();
    fprintf(stderr, "Proceso finalizado OK.\n");

    EXEC SQL COMMIT WORK RELEASE;
    return (0);

}
/******************************************************************************************/
/** Información de Versionado *************************************************************/
/******************************************************************************************/
/** Pieza                                               : */
/**  %ARCHIVE% */
/** Identificador en PVCS                               : */
/**  %PID% */
/** Producto                                            : */
/**  %PP% */
/** Revisión                                            : */
/**  %PR% */
/** Autor de la Revisión                                : */
/**  %AUTHOR% */
/** Estado de la Revisión ($TO_BE_DEFINED es Check-Out) : */
/**  %PS% */
/** Fecha de Creación de la Revisión                    : */
/**  %DATE% */
/** Worksets ******************************************************************************/
/** %PIRW% */
/** Historia ******************************************************************************/
/** %PL% */
/******************************************************************************************/

